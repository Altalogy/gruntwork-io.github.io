---
title: How to configure a production-grade CI/CD workflows for application and infrastructure code
categories: Foundations
image: TODO
excerpt: Learn about CI/CD workflows for application and infrastructure code, including the differences between the two, different CI servers, threat models, and more.
tags: ["aws", "terraform", "cicd"]
cloud: ["aws"]
---
:page-type: guide
:page-layout: post

:toc:
:toc-placement!:

// GitHub specific settings. See https://gist.github.com/dcode/0cfbf2699a1fe9b46ff04c41721dda74 for details.
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
toc::[]
endif::[]

== Intro

This guide is a comprehensive overview of how to design, configure, and implement a Continuous Integration and
Continuous Delivery pipeline for your application and infrastructure code.

=== What is Continuous Integration and Continuous Delivery?

Continuous Integration and Continuous Delivery (also widely known as CI/CD) is a software development practice that
involves developers merging their work together and deploying it to production on a regular basis (oftentimes as
frequent as multiple times per day). The goal of a Continuous Integration process is to integrate the various feature
work that the developers are individually doing often enough such that you can identify problems with the design earlier
in the process, allowing you to improve the design incrementally. Similarly, by deploying the software more frequently
to production, the Continuous Delivery process enables you to keep software packages small enough to reduce the risk and
impact of each deployment.

While CI/CD for application code is well understood in the software industry, CI/CD for infrastructure code is a
relatively new concept. This guide focuses on providing an overview of the background info, design, and implementation
of a production-ready CI/CD pipeline for infrastructure code.


=== What you'll learn in this guide

This guide consists of four main sections:

<<core_concepts>>::
  An overview of the core concepts you need to understand what a typical CI/CD pipeline entails for appliction and
  infrastructure code, including a sample workflow, infrastructure to support CI/CD, and threat models to consider to
  protect your infrastructure.

<<production_grade_design>>::
  An overview of how to configure a secure, scalable, and robust CI/CD workflow that you can rely on for your
  production application and infrastructure code. To get a sense of what production-grade means, check out
  link:/guides/foundations/how-to-use-gruntwork-infrastructure-as-code-library#production_grade_infra_checklist[The production-grade infrastructure checklist].

<<deployment_walkthrough>>::
  A step-by-step guide to deploying a production-grade CI/CD pipeline in AWS using code from the Gruntwork
  Infrastructure as Code Library.

<<next_steps>>::
  What to do once you've got your CI/CD pipeline set up.


=== What this guide will not cover

CI/CD for infrastructure code is a large topic and a single guide can not cover everything there is to the topic. As
such there are several items that this guide will not cover, including:

A pipeline for setting up new environments::
  This guide will focus on a CI/CD workflow for making changes to infrastructure in an environment that is already set
  up. In other words, the design and implementation of the pipeline covered in this guide intentionally does not solve
  the use case of infrastructure code for setting up an environment from scratch. Setting up new environments typically
  require complex deployment orders and permissions modeling that complicate the task. This makes it hard to automate in
  a reasonable fashion that still respects the threat model we cover here.

Automated testing and feature toggling strategies for infrastructure code::
  An important factor of CI/CD pipelines is the existence of automated testing and feature toggles. Automated tests give
  you the confidence in the code before it is deployed to production. Similarly, feature toggles allow you to partially
  integrate and deploy code for a feature without enabling it. By doing so, you are able to continuously integrate
  lareger new developments over time. This guide will briefly introduce automated testing and feature toggles for
  infrastructure code, but will not do a deep dive on the subject.


== Core Concepts

=== Why is it important to have CI/CD?

TODO


=== Trunk-based development model

The most common way to implement Continuous Integration is to use a _trunk-based development model_.

TODO


=== CI/CD for application code

Before diving into what a CI/CD workflow for infrastructure code might look like, let's first start by going over a
typical workflow of taking application code (e.g, a Ruby on Rails or Java/Spring app) from development to production.
CI/CD workflows for application code is reasonably well understood in the DevOps industry, so you'll probably be
familiar with parts of it.

For the purposes of going through this workflow, we will assume the following:

- The application code lives in source control.
- We are using a trunk-based development model (link:#trunk-based-development-model[described above]).
- The application has already been in development for sometime and there is a version of it in production.

==== Clone copy of source code and create a new branch

The first step in making changes to the code in the repository is to ensure a version of the code exists locally.
You will also want to ensure that you can run the code locally to verify your changes in an iterative manner. Note
being able to run the code locally is likely to slow your development process as the only way to know if your changes
work is through the CI infrastructure which is typically considerably slower to work interactively.

Additionally, you will want to ensure that your work doesn't conflict or break the workflow of others. In the initial
stages of development, your code is likely to be more erratic as it will not have gone through all the automated checks
of the workflow (e.g automated tests and code reviews). You will want to avoid integrating code at this stage, until you
have gone through enough checks to feel confident in the code. Typically you create a separate, shortlived branch from
trunk that you use for tracking your work.

==== Run the code locally

Typically it is a good practice to sanity check the local copy before making any changes to it. You want to ensure that
you are starting from a clean slate to avoid conflicting an existing bug that breaks the code with something that you
introduced during development. If any issues have slipped through the cracks and were merged to master, you want to know
those before starting on your implementation.

Testing the code locally typically includes both manual and automated tests. For example, if you had a web application
written in a general purpose programming language such as Ruby, you might manually test the code by starting the server
and hitting a few known endpoints with `curl`:

----
$ ruby web-server.rb

[2019-06-15 15:43:17] INFO  WEBrick 1.3.1
[2019-06-15 15:43:17] INFO  ruby 2.3.7 (2018-03-28)
[2019-06-15 15:43:17] INFO  WEBrick::HTTPServer#start: port=8000

$ curl http://localhost:8000
Hello, World
----

You might also run the automated test suite for your web server locally to get a wider coverage area than just the
manual testing:

----
$ ruby web-server-test.rb

(...)

Finished in 0.633175 seconds.
\--------------------------------------------
8 tests, 24 assertions, 0 failures, 0 errors
100% passed
\--------------------------------------------
----

It is important to note that you can verify and test the code entirely in the local environment. This is not true for
infrastructure code where testing requires spinning up infrastructure in the cloud.

==== Make code changes

Now t


=== CI/CD for infrastructure code

=== CI/CD platforms

=== Threat model of CI/CD


== Production-grade design

=== Use CI servers as workflow engine

=== Identify minimal IAM permissions for a deployment

=== Run infrastructure deployment outside of CI servers

=== Implement approval flows

=== Lock down VCS systems


== Deployment walkthrough

=== Pre-requisites

=== Lock down VCS

=== Deploy a VPC

=== Deploy the ECS Deploy Runner

=== Configure IAM permissions for the ECS Task

=== Configure CI server


== Next steps
