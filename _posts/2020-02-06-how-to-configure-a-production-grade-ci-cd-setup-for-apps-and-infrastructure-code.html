<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<title>Intro</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
:not(pre)>code.nobreak{word-wrap:normal}
:not(pre)>code.nowrap{white-space:nowrap}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
td.tableblock>.content>:last-child.sidebarblock{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="article">
<div id="header">
</div>
<div id="content">
<hr>
<div class="paragraph">
<p>title: How to configure a production-grade CI/CD workflow for infrastructure code
categories: Automations and Workflows
image: TODO
excerpt: Learn about CI/CD workflows for infrastructure code, including the differences with application code, different CI servers, threat models, and more.
tags: ["aws", "terraform", "cicd"]
cloud: ["aws"]
---
:page-type: guide
:page-layout: post</p>
</div>
<div class="sect1">
<h2 id="_intro">Intro</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is a comprehensive guide of how to design, configure, and implement a Continuous Integration and Continuous
Delivery pipeline for your infrastructure code. This guide will walk you through the steps to set up a secure CI/CD
pipeline using your favorite CI/CD platform (e.g Jenkins, Circle, GitLab, etc).</p>
</div>
<div class="sect2">
<h3 id="_what_is_continuous_integration_and_continuous_delivery">What is Continuous Integration and Continuous Delivery?</h3>
<div class="paragraph">
<p>Continuous Integration and Continuous Delivery (also widely known as CI/CD) are software development practices that
involve developers merging their work together and deploying it to production on a regular basis (oftentimes as
frequent as multiple times per day). The goal of a Continuous Integration process is to integrate the features developed
independently by engineers often enough such that you can identify problems with the design earlier in the process,
allowing you to improve the design incrementally. Similarly, by deploying the software more frequently to production,
the Continuous Delivery process enables you to keep software packages small enough to reduce the risk and impact of each
deployment.</p>
</div>
<div class="paragraph">
<p>While CI/CD for application code is well understood in the software industry, CI/CD for infrastructure code is a
nascent practice. This guide focuses on providing an overview of the background info, design, and implementation
of a production-ready CI/CD pipeline for infrastructure code.</p>
</div>
</div>
<div class="sect2">
<h3 id="_what_youll_learn_in_this_guide">What you&#8217;ll learn in this guide</h3>
<div class="paragraph">
<p>This guide consists of four main sections:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="#core_concepts">Core Concepts</a></dt>
<dd>
<p>An overview of the core concepts you need to understand what a typical CI/CD pipeline entails for infrastructure code,
including a comparison with CI/CD for application code, a sample workflow, infrastructure to support CI/CD, and threat
models to consider to protect your infrastructure.</p>
</dd>
<dt class="hdlist1"><a href="#production_grade_design">Production-grade design</a></dt>
<dd>
<p>An overview of how to configure a secure, scalable, and robust CI/CD workflow that you can rely on for your
production application and infrastructure code. To get a sense of what production-grade means, check out
<a href="/guides/foundations/how-to-use-gruntwork-infrastructure-as-code-library#production_grade_infra_checklist">The production-grade infrastructure checklist</a>.</p>
</dd>
<dt class="hdlist1"><a href="#deployment_walkthrough">Deployment walkthrough</a></dt>
<dd>
<p>A step-by-step guide to deploying a production-grade CI/CD pipeline in AWS using code from the Gruntwork
Infrastructure as Code Library.</p>
</dd>
<dt class="hdlist1"><a href="#next_steps">[next_steps]</a></dt>
<dd>
<p>What to do once you&#8217;ve got your CI/CD pipeline set up.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_what_this_guide_will_not_cover">What this guide will not cover</h3>
<div class="paragraph">
<p>CI/CD for infrastructure code is a large topic and a single guide cannot cover everything there is to the topic. As
such there are several items that this guide will not cover, including:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">A pipeline for setting up new environments</dt>
<dd>
<p>This guide will focus on a CI/CD workflow for making changes to infrastructure in an environment that is already set
up. In other words, the design and implementation of the pipeline covered in this guide intentionally does not solve
the use case of infrastructure code for setting up an environment from scratch. Setting up new environments typically
require complex deployment orders and permissions modeling that complicate the task. This makes it hard to automate in
a reasonable fashion that still respects the threat model we cover here.</p>
</dd>
<dt class="hdlist1">Automated testing and feature toggling strategies for infrastructure code</dt>
<dd>
<p>An important factor of CI/CD pipelines is the existence of automated testing and feature toggles. Automated tests give
you confidence in the code before it is deployed to production. Similarly, feature toggles allow you to partially
integrate and deploy code for a feature without enabling it. By doing so, you are able to continuously integrate new
developments over time. This guide will briefly introduce automated testing and feature toggles for infrastructure
code, but will not do a deep dive on the subject. You can learn more about best practices for automated testing in our
talk
<a href="https://blog.gruntwork.io/new-talk-automated-testing-for-terraform-docker-packer-kubernetes-and-more-cba312171aa6">Automated
testing for Terraform, Docker, Packer, Kubernetes, and More</a> and blog post
<a href="https://www.ybrikman.com/writing/2016/02/14/agility-requires-safety/">Agility requires safety</a>.</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="core_concepts">Core Concepts</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="why_is_it_important_to_have_cicd">Why is it important to have CI/CD?</h3>
<div class="paragraph">
<p>To understand the benefits of CI/CD, it is worth exploring the opposite: <em>late integration and late delivery (LI/LD)</em>.
We will explain LI/LD using a thought experiment about building the International Space Station (ISS).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/assets/img/guides/infrastructure-cicd-pipeline/iss-components.png" alt="iss components">
</div>
<div class="title">Figure 1. Components of the International Space Station</div>
</div>
<div class="paragraph">
<p>The ISS consists of dozens of components, as shown in the image above. Each component is built by a team from a
different country, with a central team responsible for organizing development. In LI/LD,
you would organize the development by designing all the components in advance, and then have each team go
off and work on their component in <em>total isolation</em>. There is complete trust in the design and the teams such that
there is no need to check in and integrate the components along the way. When all the teams are done, each team launches
the component into space and then put all the components together at the same time in space, <em>for the first time</em>.</p>
</div>
<div class="paragraph">
<p>It isn&#8217;t hard to imagine that this could be disastrous: one team would think the other team was responsible for wiring
while that team thought everything would be wireless; all the teams would use the metric system except one; everyone cut
toilets from the scope thinking some other team is sure to include it. Finding all of this out once everything has
already been built and is floating in outer space means that fixing the problems will be very difficult and expensive.</p>
</div>
<div class="paragraph">
<p>While it is hard to imagine that anyone would build the ISS in this way, unfortunately this model of development is
fairly common in the software industry. Developers work in total isolation for weeks or months at a time on <em>feature
branches</em> without integrating their work with other teams, and then try to merge all the work together at the last
minute moments before release. As a result, the integration process is very expensive and takes days or weeks fixing merge
conflicts, tracking down subtle bugs, and trying to stabilize release branches.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/assets/img/guides/infrastructure-cicd-pipeline/feature-branch-merge-conflict.png" alt="feature branch merge conflict">
</div>
<div class="title">Figure 2. Many teams employ a practice of working on their features over long periods of time on isolated branches. These long lived feature branches have higher chances of having big conflicts to resolve when integrated.</div>
</div>
<div class="paragraph">
<p>In contrast, the Continuous Integration and Continuous Delivery model of development promotes more cross team
communication and integration work as development progresses. Going back to the ISS thought experiment, a CI/CD style of
building the ISS would work by collaborating on a design. Rather than each team working in isolation, there
would be regular checkpoints throughout the process where the teams come together to try to test and integrate all the
components, and update the design if there are problems. As components are completed and integration tests validate the
design, they are launched into space and assembled incrementally as new components arrive.</p>
</div>
<div class="paragraph">
<p>Rather than integrating at the last moment, CI/CD encourages development teams to integrate their work together
regularly, with smaller deltas between each change. This exposes problems with the design earlier in the process,
ensuring that there is ample time for improvements and corrections.</p>
</div>
</div>
<div class="sect2">
<h3 id="trunk_based_development_model">Trunk-based development model</h3>
<div class="imageblock">
<div class="content">
<img src="/assets/img/guides/infrastructure-cicd-pipeline/trunk.png" alt="trunk">
</div>
<div class="title">Figure 3. Trunk branch with a continuous stream of commits.</div>
</div>
<div class="paragraph">
<p>The most common way to implement CI/CD is to use a <em>trunk-based development model</em>. In trunk-based development, all the
work is done on the same branch, called <code>trunk</code> or <code>master</code> depending on the Version Control System (VCS). You would
still have feature branches that developers work on to facilitate review processes, but typically these are tiny and
short-lived containing only a handful of commits. Everyone actively merges their work back into trunk on a regular
basis, oftentimes multiple times per day (Continuous Integration). Then, as <code>trunk</code> or <code>master</code> is updated, the work is
immediately deployed into the active environments so that they can be tested further (Continuous Delivery).</p>
</div>
<div class="paragraph">
<p>Can having all developers work on a single branch really scale? It turns out that trunk-based development is used by
thousands of developers at <a href="https://www.wired.com/2013/04/linkedin-software-revolution/">LinkedIn</a>,
<a href="https://paulhammant.com/2013/03/13/facebook-tbd-take-2/">Facebook</a>, and
<a href="https://www.youtube.com/watch?v=W71BTkUbdqE">Google</a>. How are these software giants able to manage active trunks on the
scale of billions of lines of code with 10s of thousands of commits per day?</p>
</div>
<div class="paragraph">
<p>There are two factors that make this possible:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Small, frequent commits reduce the scope of each integration</dt>
<dd>
<p>It turns out that if you integrating small amounts of code on a regular basis, the number of conflicts that arise is
also fairly small. Instead of having big, monolithic merge conflicts, each conflict that arises will be in a tiny
portion of the work being integrated. In fact, these conflicts can be viewed as helpful as it is a sign that there is
a design flaw. These integration challenges are part and parcel to distributed software development projects. You&#8217;ll have to deal with conflicts no matter what, and it is going
to be easier to deal with conflicts that arise from one or two days of work than with conflicts that represents months
of work.</p>
</dd>
<dt class="hdlist1">Automated testing</dt>
<dd>
<p>When frequent development happens on <code>trunk</code>/<code>master</code>, naturally it can make the branch unstable. A broken
<code>trunk</code>/<code>master</code> is something you want to avoid at all costs in trunk-based development as it could block all
development. To prevent this, it is important to have a self-testing build with a solid automated testing suite. A
self-testing build is a fully automated build process that is triggered on any work being committed to the repository.
The associated test suite should be complete enough that when they pass, you can be confident the code is stable.
Typically code is only merged into the trunk when the self-testing build passes.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="types_of_infrastructure_code">Types of infrastructure code</h3>
<div class="paragraph">
<p>Before diving into CI/CD workflows, it is important to understand the different types of infrastructure code that is
available. There are two distinct types of infrastructure code:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Infrastructure Modules</dt>
<dd>
<p>Modules are bundles of infrastructure code that can be used to deploy a specific component of your architecture.
For example, many companies have modules for deploying private networks using Virtual Private Clouds (VPCs),
databases, docker clusters (e.g Elastic Container Service, Kubernetes, Nomad), etc. Think of modules as the
"blueprints" that define the way your company configures infrastructure.</p>
</dd>
<dt class="hdlist1">Live Infrastructure Configurations</dt>
<dd>
<p>Live infrastructure configurations are specific parameters for each component in your architecture. The live
configurations are the frontend for your infrastructure deployments. For example, you might define your dev
environment as a series of configuration files for the modules that specify the various parameters specific to
development (e.g sizing small instances, naming them with <code>dev</code>, using accounts that are accessible by all developers,
etc). If the modules are "blueprints" then the live configuration contain the "houses" that were built using the
"blueprints."</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Typically you would have separate repositories for each of these (e.g <code>infrastructure-modules</code> for modules and
<code>infrastructure-live</code> for live configuration). Organizing your infrastructure code in this way ensures that you can
better test the code before they are used to deploy your environments.</p>
</div>
<div class="paragraph">
<p>Isolating modules from live configuration allows you to:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Update component infrastructure code without affecting environments</dt>
<dd>
<p>If you use versioned, immutable snapshots of the module code, you can decouple the modules from the environments that
use them. For example, prod might use version <code>0.4.2</code> of your RDS module, while dev might be using version <code>0.5.0</code>
which includes a number of improvements to help with debugging performance issues. But since there is a backwards
incompatibility between the two versions, you are waiting to roll out <code>0.5.0</code> to prod until you have a window of
opportunity to have scheduled downtime with prod. By decoupling the module code from the live infrastructure, you can
continue improving the component infrastructure code in isolation.</p>
</dd>
<dt class="hdlist1">Test infrastructure at the component level</dt>
<dd>
<p>Focusing modules down to specific components makes it easier to write tests for your infrastructure code. For example,
to test your RDS module, you might use relaxed network constraints that make your database wide open at test time. You
would not want to do this in any environment that runs your application, but when you are focusing on whether or not
your RDS module deploys a functional database, having to worry about bastion hosts and tunneling requests might get in
the way. If you were not separating out module code from live configuration, the infrastructure code can&#8217;t be reused
to deploy an RDS database in an isolated sandbox account, because it will be hard coded to the specific environment it
was written for. Testing in this way allows you to build confidence in your infrastructure code prior to rolling it
out to each environment.</p>
</dd>
<dt class="hdlist1">Keep your live configuration DRY</dt>
<dd>
<p>Decoupling the component infrastructure code from the environment configurations allows you to reuse the component
code for each of your environments. Your <code>dev</code>, <code>staging</code>, and <code>production</code> environments are likely to be
architecturally similar, using the same components across the stack. Like with any code, you don&#8217;t want to repeat
yourself with lots of boilerplate, and instead only want to specify what is different across the environments.
Separating out your code between modules and live configurations allows you to focus the live configuration code on
reusing the modules across each environment by invoking them with different inputs that are specific to the
environment.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>There are distinct differences in the way the code is tested, used, and deployed between the two flavors of
infrastructure code. These differences are important to consider when designing CI/CD workflows, as they lead to many
differences in the implementation of the pipeline. In the next seciton, we will walk through a typical CI/CD workflow
and compare and contrast the pipeline between the three flavors of code we&#8217;ve talked about so far: application code,
infrastructure modules, and live infrastructure configuration.</p>
</div>
</div>
<div class="sect2">
<h3 id="cicd_workflows">CI/CD workflows</h3>
<div class="paragraph">
<p>Now that we have gone over what, why, and how CI/CD works, let&#8217;s take a look at a more concrete example walking through
the workflow.</p>
</div>
<div class="paragraph">
<p>The following covers the steps of a typical CI/CD workflow. Any CI/CD workflow, whether it be for infrastructure code or
application code, generally follow these steps. However, the details of some of the steps differ widely. We&#8217;ll go over
each step of the process and then highlight the differences in implementation for the three flavors of code we covered:
application code, infrastructure modules, and live infrastructure configuration.</p>
</div>
<div class="paragraph">
<p>For the purposes of illustrating this workflow, we will assume the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The code lives in version control.</p>
</li>
<li>
<p>We are using a trunk-based development model.</p>
</li>
<li>
<p>The code has already been in development for a while and there is a version running in production.</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="#clone_a_copy_of_the_source_code">Clone a copy of the source code and create a new branch</a></p>
</li>
<li>
<p><a href="#run_the_code_locally">Run the code locally</a></p>
</li>
<li>
<p><a href="#make_code_changes">Make code changes</a></p>
</li>
<li>
<p><a href="#submit_changes_for_review">Submit changes for review</a></p>
</li>
<li>
<p><a href="#run_automated_tests">Run automated tests</a></p>
</li>
<li>
<p><a href="#merge_and_release">Merge and release</a></p>
</li>
<li>
<p><a href="#deploy">Deploy</a></p>
</li>
</ol>
</div>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="clone_a_copy_of_the_source_code">Clone a copy of the source code and create a new branch</h4>
<div class="paragraph">
<p>Typically the first step in making changes to any code base is to clone the repository locally and begin development on
a new branch. Having a local copy makes it easier to iterate on the changes, and using an isolated branch allows you to
push code back to the central repository without breaking the main line of code (trunk) that everyone else is working
on.</p>
</div>
<div class="paragraph">
<p>It is important to keep the trunk clean in a trunk-based development model, as all new work starts from the trunk.
If the trunk has broken code, then new development can&#8217;t be done reliably because there will be no way for everyone on
the team to test their code. Note that this branch should be short lived. That is, you should strive to get the work
completed and merged in a few days to avoid large merge conflicts.</p>
</div>
<div class="paragraph">
<p>If you are using <code>git</code>, this step translates to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>git clone REPO_URL
git checkout -B NEW_BRANCH_NAME</pre>
</div>
</div>
<div class="paragraph">
<p>Whether you are developing application code, infrastructure modules, or live infrastructure config, making changes on a
separate branch is a good idea. However, what you do to test that code will be vastly different, as we&#8217;ll cover in the
next section.</p>
</div>
</div>
<div class="sect3">
<h4 id="run_the_code_locally">Run the code locally</h4>
<div class="paragraph">
<p>Before making any code changes, you want to make sure that you are working off of a clean slate. If you start off of
broken code, you won&#8217;t know if the feature isn&#8217;t working because of a bug in the trunk, or if it is your code. It is
always a good idea to run the code locally to sanity check the current state of trunk to make sure you are starting from
working code.</p>
</div>
<div class="paragraph">
<p>How to run the code locally will be very different depending on the type of code you are working with:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Application Code</dt>
<dd>
<p>You can typically spin up a local environment for application code to test it out. For example, if you had a simple
web server written in a general purpose programming language such as Ruby, you can run the server code to bring up a
local copy of the application that you can interact with (e.g <code>ruby web-server.rb</code>). You can then manually test it by
loading the web server in the browser. Alternatively, you could run the automated test suite associated with your
application (e.g <code>ruby web-server-test.rb</code>). The point is that (almost) everything can be done locally for fast
iteration.</p>
</dd>
<dt class="hdlist1">Infrastructure Modules</dt>
<dd>
<p>You will need to bring up live infrastructure to test infrastructure code. Unlike with application code, there is no
way to have a true and complete local copy of a cloud. Therefore, the only way to know for sure your infrastructure
code works is by making the actual API calls to the cloud to deploy it. With infrastructure modules, this involves
deploying the module into a sandbox environment. For example, to test a terraform module, you can define example code
that sets up the necessary resource dependencies that the module needs, and then deploy that into your sandbox with
<code>terraform apply</code>. You can then inspect the deployed resources to make sure they are functioning as expected. For
convenience, this process could be captured in an automated test using a framework such as
<a href="https://terratest.gruntwork.io/">Terratest</a>.</p>
</dd>
<dt class="hdlist1">Live Infrastructure Config</dt>
<dd>
<p>Locally testing live infrastructure config is more difficult than either application code or infrastructure modules.
Unlike with infrastructure modules, it is difficult to deploy the live infrastructure config temporarily as the code
is tied to a specific live environment by nature of the code. After all, this is the configuration to manage live
infrastructure. To illustrate this point, consider a scenario where you are working on adding a new component to your
environments, and you are at the point of reflecting your changes to prod. Would you want to deploy that code to your
live production environment off of an unreviewed branch? Given that, the only real test you can do for live
infrastructure config is to do a dry run of your infrastructure code. Most Infrastructure as Code tools support a dry
run of the code to check what it would do against your environment. For example, with Terraform, you could run
<code>terraform plan</code> to sanity check the planned actions Terraform will take. This is especially useful for sanity
checking a fresh clone of the code. The trunk should be a true reflection of the live environment, so you should
expect there to be no changes to make on a fresh clone of trunk.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="make_code_changes">Make code changes</h4>
<div class="paragraph">
<p>Now that you have a working local copy, you can start to make changes to the code. This process is done iteratively
while checking for validity of the changes along the way with manual or automated testing. It is important to invest
some time and effort in making the feedback cycle short, as it directly translates to your development speed. The faster
you can iterate, the more tests you can run, and the better your code will be.</p>
</div>
<div class="paragraph">
<p>How you make changes to the code will be largely the same for the three flavors of code we covered, although how you
test your changes and the test cycles will be different. Typically, testing application code can be done in seconds
(because everything is local), and testing live infrastructure config can be done in minutes (because you are only doing
a dry run). However, testing infrastructure modules can take a long time since you need to deploy infrastructure (on the
order of 10s of minutes). For ideas on how to improve the test cycles for infrastructure modules, take a look at
<a href="https://terratest.gruntwork.io/docs/testing-best-practices/iterating-locally-using-test-stages/">Iterating locally using
test stages</a> in the Terratest documentation.</p>
</div>
</div>
<div class="sect3">
<h4 id="submit_changes_for_review">Submit changes for review</h4>
<div class="paragraph">
<p>Once the code implementation is done and the testing passes, the next step is to submit it for review. You want to focus
your review process on things that are hard to check through automated testing, such as checking security flaws,
reviewing general code design, enforcing style guides, or identifying potential performance issues on larger data sets.
Code review processes are also a great way to share knowledge across the team. The reviewer will oftentimes share
valuable insights on the code that you might not have thought of.</p>
</div>
<div class="paragraph">
<p>How thorough the review should be depends on the amount of automated testing. If you have a comprehensive test suite
that everyone on the team has confidence in, then it is not necessary to have a thorough review process. On the other
hand, if you no automated tests or working on an area that can&#8217;t be tested automatically (e.g live infrastructure code),
then you&#8217;ll want as many eyes as possible reviewing the code.</p>
</div>
</div>
<div class="sect3">
<h4 id="run_automated_tests">Run automated tests</h4>
<div class="paragraph">
<p>To help with code review, you should also set up a CI server (such as Jenkins or CircleCI) with commit hooks that
automatically trigger testing of any branch that is submitted for review. Running the automated tests in this fashion
not only ensures that the code passes all the tests, but also verifies that it runs on multiple platforms and not just
on the developer&#8217;s local workstation. This is also a good way to run an extensive test suite that takes a long time to
run. Most developers will run a subset of the tests that relate to the feature work being done, as it leads to faster
feedback cycles.</p>
</div>
<div class="paragraph">
<p>The tests that the CI server runs will be different across the three flavors of code:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Application Code</dt>
<dd>
<p>The CI server should run the entire automated test suite for the application code, and report the results as a
summary. Since automated testing has clear results (whether it failed or passed), you can usually summarize the report
down to a single icon (a green check mark to indicate success or a red "X" for failure). For reporting failures, most
CI servers has first class support for consuming the results of the test framework to display cleanly in the UI.</p>
</dd>
<dt class="hdlist1">Infrastructure Modules</dt>
<dd>
<p>Like with application code, the CI server should run automated tests for infrastructure modules. However, since
tests for infrastructure modules can cost money and can take a long time to run, it is recommended to only run the
tests for the modules that changed instead of doing a regression test for all the modules on every commit. You can run
a nightly build that runs the whole suite on a regular interval that is less frequent than developers updating the
code. Like with application code, automated infrastructure testing is also very clear when it comes to results so
you can use the same reporting mechanisms to share results back to the PR.</p>
</dd>
<dt class="hdlist1">Live Infrastructure Config</dt>
<dd>
<p>For live infrastructure config, the CI server should perform the dry run of the infrastructure and post the entire
log of the run. Analyzing a plan is hard to automate since the rules surrounding what changes are ok and what changes
are not is potentially limitless. Therefore, the only way to review the results is by looking at the entire dry run.
Note that this has potential security issues as the logs for a dry run would typically include secrets. You will want
to be sensitive to who has access to the logs, and potentially encrypt the results before it is posted.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="merge_and_release">Merge and release</h4>
<div class="paragraph">
<p>Once the code passes automated checks and goes through the review process, it is ready to be integrated into the trunk.
At this point, you have done the best you could to ensure the code won&#8217;t break the current trunk and additional checks
are likely to hit diminishing returns. Once you merge the code into trunk, you will also want to generate a new,
immutable, versioned release artifact that can be deployed (see
<a href="https://blog.gruntwork.io/why-we-use-terraform-and-not-chef-puppet-ansible-saltstack-or-cloudformation-7989dad2865c#b264:">Mutable
infrastructure vs Immutable infrastructure</a> for a discussion on a benefit of immutable artifacts). What the release
artifact looks like depends on the type of code you are working with:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Application Code</dt>
<dd>
<p>The release artifact will vary widely from project to project for application code. This could be anything from a
source file tarball or a <code>jar</code> file executable to a docker image or a VM image. Whatever format the artifact is in,
make sure the artifact is immutable (i.e., you never change it), and that it has a unique version number (so you can
distinguish this artifact from all the others).</p>
</dd>
<dt class="hdlist1">Infrastructure Modules</dt>
<dd>
<p>Infrastructure modules are typically consumed as a library in the tool. Most infrastructure as code tools consume
libraries directly from a Git repository. For example, with Terraform you can consume modules through module blocks
that reference a Git repository (see
<a href="https://www.terraform.io/docs/configuration/modules.html">the official documentation</a> for more details). In this case,
using a Git tag to mark a revision with a human friendly name is sufficient to generate the release artifact.</p>
</dd>
<dt class="hdlist1">Live Infrastructure Config</dt>
<dd>
<p>For live infrastructure config, there is typically no release artifact. Live infrastructure code doesn&#8217;t need to be
packaged to deploy as it is directly consumable. For example, for Terraform or Terragrunt live config, you can
directly run <code>terraform apply</code> or <code>terragrunt apply</code> on the repo. In general, it is not necessary to tag your commits
for live infrastructure config because in practice you will end up deploying every commit of trunk.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>It is worth expanding a bit on the reason why live infrastructure config does not have any release artifact. To
understand this, it is worth looking at what it means to have a working trunk on live infrastructure config. If you
recall from <a href="#run_the_code_locally">Run the code locally</a>, the only way to test live infrastructure config is by doing a dry run of the code.
If the only way to test live infrastructure config is with dry runs, then you would want to make sure that there are no
new changes to make to the live environments when you start. This is so that you get an accurate representation of the
changes that are being introduced, since you don&#8217;t want to be differentiating between existing changes that will be
applied from trunk and the changes that will be applied with your new code.</p>
</div>
<div class="paragraph">
<p>Given that, the definition of a "clean build" for the trunk with live infrastructure config is that a dry run returns no
changes to make. This in turn means that the latest state of trunk that you are working off of, should be a
representation of what is actually deployed in your environments.</p>
</div>
<div class="paragraph">
<p>This leads to what we call <em>The Golden Rule of Infrastructure Code:</em></p>
</div>
<div class="paragraph">
<p><strong><em>The master branch of the live repository should be a 1:1 representation of what&#8217;s actually deployed.</em></strong></p>
</div>
<div class="paragraph">
<p>You will want to do everything that is in your power to maintain this representation to streamline your development.</p>
</div>
</div>
<div class="sect3">
<h4 id="deploy">Deploy</h4>
<div class="paragraph">
<p>Now that you have a release artifact, the final stage of the process is to deploy the code. The act of deploying the
code immediately after generating the release is Continuous Deployment (CD).</p>
</div>
<div class="paragraph">
<p>What it means to "deploy the code" is significantly different across the three flavors. In fact, deploying your
application code and infrastructure modules require changing and deploying live infrastructure config. After all, your
live infrastructure config is a reflection of what&#8217;s actually deployed, so deploying application or infrastructure
changes require updating the live infrastructure config.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s take a look at how to deploy each flavor of code:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Application Code</dt>
<dd>
<p>Deploying the release artifact to your environment depends on how the code is packaged. If it is a library, then it
will be deployed when the application that consumes it updates the library version. In this case, nothing needs to be
done to deploy it to the application. For services, you would need to deploy the application onto live servers so that
it is running. For docker images, this might mean updating your service definitions for the docker cluster (e.g ECS or
Kubernetes). For machine images, this might mean updating your autoscaling group to deploy instances with the new
image. Regardless of how your application is deployed, it is important to reflect the changes in your live
infrastructure config to perform the deployment, so that you maintain the Golden Rule of Infrastructure Code. Note
that there are various strategies for deploying application code, such as canary and blue-green deployments. We will
not get into details here, but you can refer to our post
<a href="https://blog.gruntwork.io/how-to-use-terraform-as-a-team-251bc1104973#7dd3">How to use Terraform as a team</a> for an
overview of various rollout strategies.</p>
</dd>
<dt class="hdlist1">Infrastructure Modules</dt>
<dd>
<p>To deploy your infrastructure modules, you need to create or update references to the modules in your live
infrastructure config. If the module is already deployed, this may be as simple as bumping the ref tag in your live
config. However, if the module is being deployed for the first time, then this will require creating a new
configuration in your live infrastructure config to deploy the module. In either case, the only way to deploy
infrastructure modules is by making the corresponding edits to the live infrastructure config to roll out the changes
across your environments. Note that because infrastructure changes are higher risk than application code, you will
want to make sure to roll out your infrastructure in stages. That is, you should fully roll out the changes in a
pre-prod environment before moving on to deploying in prod.</p>
</dd>
<dt class="hdlist1">Live Infrastructure Config</dt>
<dd>
<p>For live infrastructure config, deploying the code is the act of applying the code to the live environment. This
depends on the tool. For example, your terraform code can be applied with <code>terraform apply</code> or <code>terragrunt apply</code>,
while Kubernetes manifests require <code>kubectl apply</code>.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Regardless of the code, the important thing about the deployment process is that you should automate as many steps of
the process as possible. Just like with automated testing on code review, you should set up a CI server to automatically
deploy your code across the various environments, to the extent that it is safe. You can automate many steps of the
deployment depending on the risk profile of the change:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Application Code</dt>
<dd>
<p>For application code, you should be able to automate the entire deployment as the surface area of each change should
be fairly small and localized to just the application. Additionally, application code have standard rollback
practices that make it easy to undo. Automating the deployment of application code requires automatically patching
your live infrastructure config. In most cases, the changes are simple enough that a single regex or sed call should
be sufficient (e.g bumping the version tag of a docker image). Note that the roll out of the deployment should be
handled as part of the automated deployment of the live infrastructure config.</p>
</dd>
<dt class="hdlist1">Infrastructure Modules</dt>
<dd>
<p>With infrastructure modules, depending on which module is being updated, an automated deployment may be risky. In a
world where a single name change could cause the database to be recreated, it pays off to be extra cautious with the
deployment. At most, you should only automatically deploy infrastructure modules to a sandbox or dev environment,
where the damage from a catastrophic failure causing the environment to be taken down is limited. Similar to
application code, automating this process could be handled with a regex or sed call that updates the ref tag in the
live infrastructure config, with the rollout being handled by the automated deployment pipeline for that code.</p>
</dd>
<dt class="hdlist1">Live Infrastructure Config</dt>
<dd>
<p>Similar to infrastructure modules, automatically deploying live infrastructure code without any oversight might be
risky depending on the change. You may want to automate specific infrastructure deployments that happen frequently and
are low risk (e.g deploying your application), but automating arbitrary infrastructure changes that may include
destroying your productiond database is not advisable. With that said, it is not practical to always manually roll out
deployments, and in some circumstances that can be more risky from a security perspective (e.g increasing attack
surface by passing out admin credentials to all your developers). A typical workflow for deploying live infrastructure
config is to have the CI server perform a dry run first, and ask for approval from an admin before proceeding to apply
the change.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_summary">Summary</h4>
<div class="paragraph">
<p>To summarize, here is a table highlighting each step of a typical CI/CD workflow and how it is implemented with each
flavor of code:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Typical CI/CD workflow for application code, infrastructure modules, and live infrastructure config.</caption>
<colgroup>
<col style="width: 14.2857%;">
<col style="width: 28.5714%;">
<col style="width: 28.5714%;">
<col style="width: 28.5715%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Workflow Step</th>
<th class="tableblock halign-left valign-top">Application Code</th>
<th class="tableblock halign-left valign-top">Infrastructure Modules</th>
<th class="tableblock halign-left valign-top">Live Infrastructure Config</th>
</tr>
</thead>
<tbody>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Clone local copy</p></th>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre>git clone $REPO
git checkout -B $NAME</pre>
</div>
</div>
<div class="paragraph">
<p>&#160;<br></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre>git clone $REPO
git checkout -B $NAME</pre>
</div>
</div>
<div class="paragraph">
<p>&#160;<br></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre>git clone $REPO
git checkout -B $NAME</pre>
</div>
</div>
<div class="paragraph">
<p>&#160;<br></p>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Run the code locally</p></th>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>Run on localhost:<br>
<code>ruby web-server.rb</code></p>
</li>
<li>
<p>Run automated tests:<br>
<code>ruby web-server-test.rb</code></p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>Run in a sandbox environment:<br>
<code>terraform apply</code></p>
</li>
<li>
<p>Run automated tests:<br>
<code>go test</code></p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>Dry run:<br>
<code>terraform plan</code></p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Make code changes</p></th>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>Change the code</p>
</li>
<li>
<p>Test manually</p>
</li>
<li>
<p>Run automated tests</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>Change the code</p>
</li>
<li>
<p>Test manually</p>
</li>
<li>
<p>Run automated tests</p>
</li>
<li>
<p>Use test stages for faster iteration</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>Change the code</p>
</li>
<li>
<p>Dry run to check changes</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Submit changes for review</p></th>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>Submit a pull request</p>
</li>
<li>
<p>Enforce coding guidelines</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>Submit a pull request</p>
</li>
<li>
<p>Enforce coding guidelines</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>Submit a pull request</p>
</li>
<li>
<p>Enforce coding guidelines</p>
</li>
<li>
<p>Review plan</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Run automated tests</p></th>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>Tests run on CI server</p>
</li>
<li>
<p>Local environment on CI server</p>
</li>
<li>
<p>Tests:</p>
<div class="ulist">
<ul>
<li>
<p>Unit tests</p>
</li>
<li>
<p>Integration tests</p>
</li>
<li>
<p>End-to-end tests</p>
</li>
<li>
<p>Static analysis</p>
</li>
</ul>
</div>
</li>
<li>
<p>Summary results</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>Tests run on CI server</p>
</li>
<li>
<p>Sandbox environment</p>
</li>
<li>
<p>Tests:</p>
<div class="ulist">
<ul>
<li>
<p>Unit tests</p>
</li>
<li>
<p>Integration tests</p>
</li>
<li>
<p>Static analysis</p>
</li>
</ul>
</div>
</li>
<li>
<p>Summary results</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>Dry run changes from CI server</p>
</li>
<li>
<p>Live environments</p>
</li>
<li>
<p>Tests:</p>
<div class="ulist">
<ul>
<li>
<p>Static analysis</p>
</li>
</ul>
</div>
</li>
<li>
<p>Full plan output</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Merge and release</p></th>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><code>git tag</code></p>
</li>
<li>
<p>Create versioned, immutable artifact:</p>
<div class="ulist">
<ul>
<li>
<p><code>docker build</code></p>
</li>
<li>
<p><code>packer build</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><code>git tag</code></p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>No release artifact</p>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Deploy</p></th>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>Automatically update Live Infrastructure Config with new image.</p>
</li>
<li>
<p>Many strategies: canary, blue-green, rolling deployment.</p>
</li>
<li>
<p>Promote immutable, versioned artifacts across environments.</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>Manually update Live Infrastructure Config with new ref tag.</p>
</li>
<li>
<p>Limited deployment strategies.</p>
</li>
<li>
<p>Promote immutable, versioned artifacts across environments.</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>Continuously deploy directly from master (with approval workflow).</p>
</li>
<li>
<p>Only one deployment strategy.</p>
</li>
</ul>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The rest of the document will discuss how we can implement the automated pieces of the workflow in a secure manner that
is ready for production. To start, let&#8217;s take a step back and define a threat model for CI/CD. This threat model will
help us ensure that we implement the necessary security controls in these CI/CD pipelines so that we cover the common
types of attack vectors for this type of workflow.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="threat_model_of_cicd">Threat model of CI/CD</h3>
<div class="paragraph">
<p>The threat model of CI/CD is different between application code, infrastructure modules, and live infrastructure config.
This largely stems from the amount of permissions required to implement each workflow:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. Permissions needed for CI/CD of each code type.</caption>
<colgroup>
<col style="width: 14.2857%;">
<col style="width: 28.5714%;">
<col style="width: 28.5714%;">
<col style="width: 28.5715%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Permissions</th>
<th class="tableblock halign-left valign-top">Application Code</th>
<th class="tableblock halign-left valign-top">Infrastructure Modules</th>
<th class="tableblock halign-left valign-top">Live Infrastructure Config</th>
</tr>
</thead>
<tbody>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">CI server logs</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">Limited (typically only need summary report as you can reproduce failures locally)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Full (can not debug without seeing the full deployment log)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Full (can not debug without seeing the full deployment log)</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Sandbox environments</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">Limited (minimal necessary to deploy artifact)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Full</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Full</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Non-prod environments</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">Limited (minimal necessary to deploy artifact)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">None</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Full</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Prod environments</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">Limited (minimal necessary to deploy artifact)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">None</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Full</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Note how CI/CD for infrastructure code requires full permissions to CI logs as well as at least one of your
environments, whereas application code can be deployed with limited permissions to the environments. This difference is
due to the fact that infrastructure modules and live infrastructure config can be used to manage any infrastructure
deployed in your environments, whereas application code is scoped to infrastructure that is relevant to the application.
Given that, the threat against CI/CD in infrastructure code is orders of magnitude higher than with application code.</p>
</div>
<div class="paragraph">
<p>Compromising the credentials used for application code may be used to take down your application in a denial of service,
but most likely will not affect databases and backups, making it recoverable after locking out the attacker.</p>
</div>
<div class="paragraph">
<p>Compromising the credentials used for infrastructure modules can cause an attacker to maliciously use your cloud
environments for various purposes, potentially costing you lots of money, but will not affect your production
environment and application. In most cases though, you can recover the costs by reporting fraud. AWS for
example is known to refund bills of accounts that were compromised.</p>
</div>
<div class="paragraph">
<p>However, compromising the credentials used for live infrastructure config can cause an attacker to do anything including
deleting all your backups. This is potentially a business ending event.</p>
</div>
<div class="paragraph">
<p>In this section we will focus on the threat model for CI/CD on live infrastructure config. However, the threats and
mitigation tactics covered are generally applicable to CI/CD for all three flavors of code.</p>
</div>
<div class="paragraph">
<p>A threat model explicitly covers what attacks are taken into consideration in the design, as well as what attacks are
<em>not</em> considered. The goal of the threat model is to be realistic about the threats that are addressable with the
tools available. By explicitly focusing attention on more likely and realistic threats, we can avoid overengineering and
compromising the usability of the solution against threats that are unlikely to exist (e.g a 5 person startup with 100
end users is unlikely to be the subject of a targeted attack by a government agency).</p>
</div>
<div class="paragraph">
<p>In this guide, the following threat assumptions are made:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Attackers' goals are to gain access to an environment that they do not already have access to. Access to an
environment includes but is not limited to:</p>
</li>
<li>
<p>The ability to read secrets that grant access to potentially sensitive data (e.g the database in prod
environment).</p>
</li>
<li>
<p>Full access over all resources to cause damage to the business (e.g ability to delete the database and all its
backups in prod).</p>
</li>
<li>
<p>Attackers can originate from both external and internal sources (in relation to the organization).</p>
</li>
<li>
<p>External attacks are limited to those that can get full access to a CI environment, but not the underlying source
code. Note that <em>any</em> CI/CD solution can likely be compromised if an attacker has access to your source code.</p>
</li>
<li>
<p>Internal attackers are limited to those with restricted access to the environments. This means that the threat model
does not consider highly trusted insiders who abuse their privileges with malicious intent.
internal ops admin with full access to the prod environment). However, an internal attacker with permissions in the
dev environment trying to elevate their access to the prod environment is considered.</p>
</li>
<li>
<p>Similarly, internal attackers are limited to those with restricted access in the CI environment and git repository. A
threat where the internal attackers can bypass admin approval in a CI pipeline or can force push deployment branches
is not considered.</p>
</li>
<li>
<p>Internal attackers can have (limited) access to the CI environment and the underlying code of the infrastructure (e.g
the git repository).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>With this threat model in mind, let&#8217;s take a look at the different CI/CD platforms.</p>
</div>
</div>
<div class="sect2">
<h3 id="cicd_platforms">CI/CD platforms</h3>
<div class="paragraph">
<p>Over the years as practices for CI/CD for application code developed many platforms emerged to support CI/CD workflows
triggered from source control. Here we will list out a few of the major CI/CD platforms that exist to support these
workflows. Note that this isn&#8217;t an exhaustive list or an endorsement of the platforms that are listed here. The goal of
this section is to give a few examples of existing platforms and solutions, and cover the trade offs that you should
consider when selecting a platform to implement your workflow on. The production-grade design that we cover in the guide
is compatible with almost any generic CI/CD platform that you select, but is an alternative to the specialized platforms
for infrastructure code.</p>
</div>
<div class="paragraph">
<p>In general, CI/CD platforms fit one of two categories: self-hosted or SaaS. Self-hosted CI/CD platforms are designed as
infrastructure that you run in your data center and cloud for managing the infrastructure in your account, while SaaS
CI/CD platforms are hosted by the vendor that provides the platform. In most cases, SaaS platforms are preferred to
self-hosted platforms to avoid the overhead of maintaining additional infrastructure to enable developer workflows,
which not only cost money but also time from your operations team to maintain the infrastructure with patches, upgrades,
uptime, etc. However, in certain fields with strict compliance requirements, it is unavoidable to have self-hosted CI/CD
platforms due to the threat model and the amount of permissions that are granted to the platform to ensure the software
can be deployed. These fields manage sensitive data that make it hard to entrust third-party platforms that are publicly
accessible with the "keys to the kingdom" that hold that data.</p>
</div>
<div class="paragraph">
<p>Additionally, CI/CD platforms can be further divided into generic platforms for any code, and specialized platforms for
application code or infrastructure code. Depending on your use case, it may be desirable to use a specialized platform
that accelerates the implementation of specific workflows as opposed to configuring a generic platform.</p>
</div>
<div class="paragraph">
<p>Here are a few examples of well-known platforms, the general category that they fit in, major features that the platform
provides, as well as how they mitigate the threat model that we cover:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="https://jenkins.io/">Jenkins</a> (self-hosted, generic)</dt>
<dd>
<p>One of the oldest CI/CD platforms, with its history going as far back as 2005 (when it was previously called
<em>Hudson</em>). Jenkins is a popular and generic platform that can be configured to support almost any kind of CI/CD, with
a wide range of plugins that enhance the experience. However, given the role that it plays in organizations, combined
with its nature of being a popular, open source platform, it is the target of frequent attacks and vulnerabilities.
Most vulnerabilities are mitigated by locking down the platform so that it is only internally accessible within a
corporate network over VPN, as well as by keeping the server, the Jenkins software, and the Jenkins plugins frequently patched. This does mean that you shouldn&#8217;t
expose the server externally to implement webhook based workflows, but rather rely on polling to detect changes.
Jenkins also provides a wide range of fine-grained permissions in its user model that allows you to lock down the
actions that your internal users can take.</p>
</dd>
<dt class="hdlist1"><a href="https://circleci.com/">CircleCI</a> (SaaS, generic)</dt>
<dd>
<p>CircleCI is a generic SaaS CI/CD platform that is more optimized for CI/CD workflows for application code than
infrastructure CI/CD, although it can be configured to implement infrastructure CI/CD workflows. It has first class
support for various application based workflows like parsing test results into a nice report in the UI, reacting to
version control events, and official docker containers for various programming languages and frameworks. However, it
does not have first class support for features that are useful with infrastructure code, such as encrypting logs
and fine grained permissions. The strength of CircleCI lies in the simplicity of its infrastructure. Being a fully
managed SaaS platform with first class support for a wide range of platforms, it is fairly easy to get up and running
on the platform in a matter of minutes. However, the downside is that you must be comfortable with using a SaaS
platform for your CI/CD workflows and having it hold your secrets that provide access to your infrastructure. Note
that CircleCI employs a respectable security model, having passed numerous compliance audits including FedRAMP. They
provide a wide variety of features to mitigate potential threats, including runtime environment isolation, restricted
contexts for finer grained permissions modeling, and audit logging to continuously monitor access.</p>
</dd>
<dt class="hdlist1"><a href="https://about.gitlab.com/">GitLab</a> (self-hosted and SaaS, generic)</dt>
<dd>
<p>GitLab is an all comprehensive platform that supports both a self-hosted mode (enterprise) or SaaS platform. Since
GitLab also provides hosting for git repositories, it creates a tight integration between the git workflows and the
CI/CD workflows that you can implement on the platform. Although GitLab is a generic CI/CD platform that can be
configured to run any workflow, GitLab also provides specialized workflows for popular infrastructure platforms like
Kubernetes. Some of its continuous deployment features include first class support for feature toggles, canary
deployments, and building docker images. While the SaaS platform is subject to external attacks, GitLab employs a
respectable security model with end to end encryption, frequent testing, and compliance audits, in addition to being
an open source and open core platform that allows for wider inspection and review of its practices. For those that can
not rely on the SaaS platform for CI/CD, you can always run GitLab EE in your own data center.</p>
</dd>
<dt class="hdlist1"><a href="https://www.runatlantis.io/">Atlantis</a> (self-hosted, specialized)</dt>
<dd>
<p>Atlantis is an open source tool optimized for git based Terraform workflows, with additional support for Terragrunt.
At its core, the platform will automatically run <code>terraform plan</code> on commits and annotate any open Pull Requests with
the <code>plan</code> output. This <code>plan</code> is stored in plan file format so that when upon merge, the exact plan is applied using
<code>terraform apply</code>. Note that Atlantis is optimized for this single workflow. That is, it cannot be made to implement
other workflows, such as building images or running infrastructure tests using terratest. Being a self-hosted
platform, you can keep your credentials internal to your data center and lock down server level access. However,
Atlantis requires a public-facing endpoint to be available so that it can listen on webhooks from the major VCS
platforms (GitHub/GitLab/Bitbucket/Azure DevOps). This means that you are relying on the security model of the
Atlantis platform to ensure that it doesn&#8217;t accidentally run infrastructure code from unwanted sources with the
credentials of the platform. To prevent unwanted deployments, you will want to ensure that you are following
<a href="https://www.runatlantis.io/docs/security.html#mitigations">all the security best practices</a> of the platform.</p>
</dd>
<dt class="hdlist1"><a href="https://www.hashicorp.com/products/terraform/">Terraform Enterprise and Terraform Cloud</a> (self-hosted and SaaS, specialized)</dt>
<dd>
<p>Terraform Cloud (SaaS) and Terraform Enterprise (self-hosted) are platforms provided by HashiCorp (the creator of
Terraform) that are optimized for Terraform workflows. Both services provide a web UI for remotely running <code>terraform
plan</code> and <code>terraform apply</code>, and can be integrated with VCS platforms to implement CI/CD workflows that remotely run
<code>terraform</code> in reaction to git. Additionally, Terraform Enterprise in particular provides the ability to manage
deployment policies and permissions as code. Note that Terraform Cloud and Enterprise are both optimized for running
<code>terraform</code>. That is, they do not support the use of external binaries such as <code>terragrunt</code> or <code>docker</code>, even when
called from within <code>terraform</code> using a <code>local-exec</code> provisioner or external data source. In terms of the threat model,
Terraform Cloud and Enterprise both implement respectable security practices, including end to end encryption backed
by HashiCorp Vault, and you have the option to run in your own data center with Terraform Enterprise to lock it down.
Note that Terraform Enterprise relies on API based integrations with the VCS platforms instead of webhooks, so it is
not necessary to have a publicly facing service when running in self-hosted mode.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Here is a table that highlights some of the features of each CI platform and their strengths and weaknesses that can be
useful in making tradeoffs:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 9.0909%;">
<col style="width: 18.1818%;">
<col style="width: 18.1818%;">
<col style="width: 18.1818%;">
<col style="width: 18.1818%;">
<col style="width: 18.1819%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top">Jenkins</th>
<th class="tableblock halign-left valign-top">CircleCI</th>
<th class="tableblock halign-left valign-top">GitLab</th>
<th class="tableblock halign-left valign-top">Atlantis</th>
<th class="tableblock halign-left valign-top">TFE and TFC</th>
</tr>
</thead>
<tbody>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Hosting</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">Self-hosted</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SaaS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SaaS or Self-hosted</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Self-hosted</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SaaS or Self-hosted</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Generic?</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specialized to terraform</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specialized to terraform</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">VCS integration</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes, with plugins</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Provides static IP addresses for IP whitelisting</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes (self-hosted)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes (TFE)</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Update commit statuses</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Annotate pull requests</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">Requires custom scripting</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Requires custom scripting</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Requires custom scripting</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Supports multiple infrastructure tools</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Limited (terraform only; additional binaries can be installed, but can not be called directly)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No (terraform only; TFE can support additional binaries, but TFC does not)</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="production_grade_design">Production-grade design</h2>
<div class="sectionbody">
<div class="paragraph">
<p>With all the core concepts out of the way, let&#8217;s now discuss how to configure a production-grade CI/CD workflow for
infrastructure code, using a platform that looks something like this:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/assets/img/guides/infrastructure-cicd-pipeline/tftg-pipeline-architecture.png" alt="tftg pipeline architecture">
</div>
<div class="title">Figure 4. Architecture of platform for running Terraform/Terragrunt CI/CD workflows.</div>
</div>
<div class="sect2">
<h3 id="use_generic_cicd_platforms_as_a_workflow_engine_but_run_infrastructure_deployments_from_within_your_account">Use generic CI/CD platforms as a workflow engine but run infrastructure deployments from within your account</h3>
<div class="paragraph">
<p>Given the limitations and tradeoffs of the various platforms we covered in <a href="#cicd_platforms">CI/CD platforms</a>, we don&#8217;t recommend
relying on a single platform for implementing the entire workflow. Instead, we recommend a hybrid solution that takes
advantage of the strengths of each platform, and cover the weaknesses. The design looks as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Use any generic CI/CD server you wish to integrate with your VCS repositories.</p>
</li>
<li>
<p>Deploy a self-hosted deployment server within your AWS account that cannot be accessed by anyone but a few admins plus
a limited trigger we&#8217;ll define below.</p>
</li>
<li>
<p>Define your CI workflows so that the CI/CD server triggers deployments against the deploy server.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This design implements separation of the concerns so that we take full advantage of the strengths of each platform,
while covering the weaknesses: relying on the CI/CD platforms to manage the workflow/pipeline, but have it trigger
infrastructure deployments on self-hosted systems that are more locked down.</p>
</div>
<div class="paragraph">
<p>We don&#8217;t want to give the CI/CD servers permissions to deploy and manage arbitrary infrastructure. CI/CD servers are
typically not secure enough to handle sensitive information, and you don&#8217;t want a server that is used for executing
arbitrary code and regularly used (and written to) by your entire dev team to have admin permissions.</p>
</div>
<div class="paragraph">
<p>Instead, we delegate this responsibility to an isolated, closed off system in the AWS account that only expose a limited
set of actions that can be triggered. That way, if anyone gets access to your CI server, they can at most kick off
builds on existing code, but they don&#8217;t get arbitrary admin access.</p>
</div>
</div>
<div class="sect2">
<h3 id="options_for_deploy_server">Options for deploy server</h3>
<div class="paragraph">
<p>The deploy server needs to be a self-hosted platform in order to satisfy the requirement for isolation. It should also
avoid executing arbitrary workflows. Finally, it should support configurations options that limit what code can run on
the server. This limits the options for what you can use as your deploy server. Here is a list of platforms that satisfy
these constraints, and their strengths and weaknesses:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Gruntwork ECS Deploy Runner Stack</dt>
<dd>
<p>This is a stack you can deploy in your AWS account that sets up an ECS task with a customizable docker container for
running <code>terraform validate</code>, <code>terraform plan</code>, and <code>terraform apply</code>, or the Terragrunt equivalent. It is also
extensible to support other commands as well, such as running <code>go test</code> for Terratest or <code>packer build</code> for building
images. To limit the ability to run arbitrary code, the stack includes a Lambda function that can be used as a trigger
which exposes a limited set of options and additional checks for source repository. It relies on serverless
technologies to limit the amount of overhead required for maintaining the system.</p>
</dd>
<dt class="hdlist1">Terraform Enterprise</dt>
<dd>
<p>Terraform enterprise provides an API for triggering runs manually (as opposed to Atlantis which only supports VCS
webhook based triggers). As a self hosted solution, it supports running in your own account. Additionally, it provides
many configuration options to limit the scope of actions including managing deployment policies as code through the
sentinel feature. However, being a stateful server, there is a high maintenance cost to keeping it up and running, in
addition to licensing cost for using the service.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>In this guide, we will use the ECS Deploy Runner Stack as the deploy server. Note that although we will not explicitly
cover it, the design is compatible with using Terraform Enterprise as the deploy server.</p>
</div>
</div>
<div class="sect2">
<h3 id="limit_triggers_for_deploy_server">Limit triggers for deploy server</h3>
<div class="paragraph">
<p>The deploy server should only expose a limited set of options for triggering deployments. That is, it should not allow
arbitrary deployments on arbitrary code. For example, the default configuration of Atlantis allows webhooks from any
repository. This means that any public repo can cause your Atlantis server to run <code>terraform plan</code> and <code>terraform apply</code>
on custom code you do not control using the permissions granted to that server. Instead, you will want to configure it
so that only certain repositories, branches, and users can trigger the workflow.</p>
</div>
<div class="paragraph">
<p>The Gruntwork ECS Deploy Runner stack mitigates this concern by only allowing triggers from a Lambda function that
exposes a limited set of actions against the deploy runner task. The lambda function:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Requires a single repository to trigger deployments by default.</p>
</li>
<li>
<p>Can be configured to limit deployments to specific branches.</p>
</li>
<li>
<p>Requires explicit IAM permissions to trigger.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can find similar mechanisms for limiting deployments in the various deploy server options.</p>
</div>
</div>
<div class="sect2">
<h3 id="use_a_vpc_to_lock_down_infrastructure_deployer">Use a VPC to lock down deploy server</h3>
<div class="paragraph">
<p>Run your infrastructure deployment workloads in a <a href="https://aws.amazon.com/vpc/">Virtual Private Cloud (VPC)</a> to isolate
the workloads in a restricted network topology (see <a href="/guides/networking/how-to-deploy-production-grade-vpc-aws">How
to deploy a production-grade VPC on AWS</a> for more information on VPCs). Configure to run all workloads in private
subnets that are not publicly accessible. Make sure to block all inbound internet access and consider blocking all
outbound access except for the minimum required (e.g, allow access to AWS APIs).</p>
</div>
</div>
<div class="sect2">
<h3 id="use_minimal_iam_permissions_for_a_deployment">Use minimal IAM permissions for a deployment</h3>
<div class="paragraph">
<p>Avoid having a single system with admin permissions for running a deployment. Instead, deploy specialized versions of
the deployment platforms with varying permissions for handling specific workflows. By separating out the concerns for
each pipeline, you can reduce the blast radius of the damage that can be done with each set of credentials. At a minimum,
you should have two versions of the infrastructure deployment system: one for deploying the application code, and which
only has the minimal permissions necessary for deploying that application; and one for deploying infrastructure code,
which has full access to the environments.</p>
</div>
</div>
<div class="sect2">
<h3 id="use_approval_flows">Use approval flows</h3>
<div class="paragraph">
<p>It is important that human review is baked into each deployment. As covered in <a href="#cicd_for_infrastructure_code">[cicd_for_infrastructure_code]</a>, it is
difficult to build an automated test suite that builds enough confidence in your infrastructure code to do the right
thing. This is important, as failed infrastructure deployments could be catastrophic to your business, and there is no
concept of rollback with infrastructure deployment tools. This means that you will almost always want to have some form
of approval workflow for your infrastructure CI/CD pipeline so that you can review what is about to be deployed. Most
generic CI/CD platforms support approval workflows. For example, CircleCI supports
<a href="https://circleci.com/docs/2.0/workflows/#holding-a-workflow-for-a-manual-approval">approval steps in its workflow
engine</a>, in addition to <a href="https://circleci.com/docs/2.0/contexts/#restricting-a-context">restricted contexts</a> to limit who
can approve the workflow.</p>
</div>
</div>
<div class="sect2">
<h3 id="lock_down_vcs_systems">Lock down VCS systems</h3>
<div class="paragraph">
<p>It is a good practice to define and store the deployment pipeline as code in the same repo that it is used. For example,
you should define the CI/CD deployment pipeline for your infrastructure code in the <code>modules</code> and <code>live</code> repositories.
However, this means that anyone with access to those repositories are free to modify the pipeline, <em>even on feature
branches</em>. This can be exploited to skip any approval process you have defined in the pipeline by creating a new branch
that overwrites the pipeline configuration.</p>
</div>
<div class="paragraph">
<p>This is not a concern if only admin users had access to the infrastructure code. Typically, however, many operations
teams want contributions to the infrastructure code from developers as well, and having any developer have the ability to
deploy arbitrary infrastructure to production without any review can be undesirable. To mitigate these concerns, you
should lock down your VCS systems:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Only deploy from protected branches</dt>
<dd>
<p>In most git hosting platforms, there is a concept of protected branches (see
<a href="https://help.github.com/en/github/administering-a-repository/about-protected-branches">GitHub docs</a> for example).
Protected branches allow you to implement policies for controlling what code can be merged in. For most platforms, you
can protect a branch such that: (a) it can never be force pushed, (b) it can never be merged to or commit to from the
cli, (c) merges require status checks to pass, (d) merges require approval from N reviewers. By only building CI
pipelines from protected branches, you can add checks and balances to ensure a review of potentially harmful
infrastructure actions.</p>
</dd>
<dt class="hdlist1">Consider a forking based workflow for pull requests</dt>
<dd>
<p>When exposing your repository to a wider audience for contribution, you can consider implementing a forking based
workflow. In this model, you only allow your trusted admins to have access to the main infrastructure repo, but anyone
on the team can read and fork the code. When non-admins want to implement changes, instead of branching from the repo,
they will fork the repo, implement changes on their fork, and then open a PR from the fork. The advantage of this
approach is that many CI platforms do not automatically run builds from a fork for security reasons. Instead, admins
manually trigger a build by pushing the forked branch to an internal branch. While this is an inconvenience to devs as
you won&#8217;t automatically see the <code>plan</code>, it prevents unwanted access to secrets by modifying the CI pipeline to log
internal environment variables or show infrastructure secrets using external data sources.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="summary_of_mitigations">Summary of mitigations</h3>
<div class="paragraph">
<p>With this production design in mind, let&#8217;s take a look at how each of the design decisions addresses the concerns of the
threat model:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Minimal access to target environments</dt>
<dd>
<p>All the infrastructure is deployed from within the accounts using a serverless platform. This means that attackers
that gain access to the underlying AWS secrets used by the CI environments will at most have the ability to run
deployments against a predefined set of code. This means that external attackers who do not have access to the source
code will at most be able to: (a) deploy code that has already been deployed before, (b) see the plan of the
infrastructure between two points of time. They will not be able to write arbitrary infrastructure code to read DB
secrets, for example. It is important to note that the IAM policies are set up such that the IAM user for CI only has
access to trigger predefined events. They do not have access to arbitrarily invoke the ECS task, as that could
potentially expose arbitrary deployments by modifying the command property (e.g use a command to <code>echo</code> some
infrastructure code and run <code>terraform</code>).</p>
<div class="ulist">
<ul>
<li>
<p>Note that there is still a risk of rolling back the existing infrastructure by attempting to deploy a previous
version. See below for potential ways to mitigate this type of attack.</p>
</li>
<li>
<p>Similarly, this alone does not mitigate threats from internal attackers who have access to the source code, as a
potential attacker with access to the source code can write arbitrary code to destroy or lookup arbitrary
infrastructure in the target environment. See below for potential ways to mitigate this type of attack.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Minimal options for deployment</dt>
<dd>
<p>The Lambda function exposes a minimal interface for triggering deployments. Attackers will only be able to trigger a
deployment against a known repo and known git refs (branches, tags, etc). To further limit the scope, the lambda
function can be restricted to only allow references to repositories that matches a predefined regular expression.
Terraform Enterprise exposes similar configuration parameters to restrict what deployments can be triggered. This
prevents attackers from creating an open source repo with malicious code that they subsequently deploy by pointing the
deploy runner to it.</p>
</dd>
<dt class="hdlist1">Restricted refs for <code>apply</code></dt>
<dd>
<p>Since many CI systems depend on the pipeline being managed as code in the same repository, internal attackers can
easily circumvent approval flows by modifying the CI configuration on a test branch. This means that potential
attackers can run an <code>apply</code> to destroy the environment or open backdoors by running infrastructure code from test
branches without having the code approved. To mitigate this, the Lambda function allows specifying a list of git refs
(branches, tags, etc) as the source of <code>apply</code> and <code>apply-all</code>. If you limit the source of <code>apply</code> to only protected
branches (see below), it prevents attackers from having the ability to run <code>apply</code> unless it has been reviewed.</p>
</dd>
<dt class="hdlist1">CI server does not need access to the source code</dt>
<dd>
<p>Since the deployments are being done remotely in separate infrastructure, the actual CI server does not need to clone the
underlying repository to deploy the infrastructure. This means that you can design your CI pipeline to only have
access to the webhook events and possibly the change list of files (to know which module to deploy), but not the
source code itself. This can further decrease the effect of a potential breach of the CI server, as the attacker will
not have the ability to read or modify the infrastructure code to use the pipeline to their advantage.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>These mitigations alone will not prevent all attacks defined in the threat model. For example, an internal
attacker with access to the source code can still do damage to the target environments by merging in code that removes
all the infrastructure resources, thereby destroying all infrastructure when the <code>apply</code> command is run. Or, they could
expose secrets by writing infrastructure code that will leak the secrets in the logs via a <code>local-exec</code> provisioner.
Note that <em>any</em> CI/CD solution can likely be compromised if an attacker has full access to your source code.</p>
</div>
<div class="paragraph">
<p>For these types of threats, your best bet is to implement various policies and controls on the source control repository
and build configurations:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="#use_approval_flows">Use approval flows</a></dt>
<dd>
<p>In addition to providing a moment to pause and inspect the exact infrastructure changes that are about to be deployed,
approval workflows in the CI server can mitigate attacks such that attackers will need enough privileges on the CI
server to approve builds in order to actually modify infrastructure. This can mitigate potential attacks where the
attacker has access to the CI server to trigger arbitrary builds manually (e.g to run a previous job that is deploying
an older version to roll back the infrastructure), but not enough access to approve the job. Note that this will not
mitigate potential threats from internal attackers who have enough permissions to approve builds.</p>
</dd>
<dt class="hdlist1"><a href="#lock_down_vcs_systems">Lock down VCS systems</a></dt>
<dd>
<p>As mentioned in the previous section, it is important that you implement various controls on the VCS repositories.
Once you implement a CI/CD pipeline, access to source code translates to access to your infrastructure environments,
so you will want to reflect the same kind of security controls you implement on your environments in your VCS
repositories.</p>
</dd>
<dt class="hdlist1">Avoid logging secrets</dt>
<dd>
<p>Our threat model assumes that attackers can get access to the CI servers, which means they will have access to the
deployment logs. This will include detailed outputs from a <code>terraform plan</code> or <code>apply</code>. While it is impossible to
prevent terraform from leaking secrets into the state, it is possible to avoid terraform from logging sensitive
information. Make use of PGP encryption functions or encrypted environment variables / config files (in the case of
service deployments) to ensure sensitive data does not show up in the plan output. Additionally, tag sensitive outputs
with the <code>sensitive</code> keyword so that terraform will mask the outputs.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_summary_of_deployment_sequence">Summary of deployment sequence</h3>
<div class="paragraph">
<p>To put it all together, the following sequence diagram shows how all the various components work together:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/assets/img/guides/infrastructure-cicd-pipeline/tftg-pipeline-sequence-diagram.png" alt="tftg pipeline sequence diagram">
</div>
<div class="title">Figure 5. Sequence diagram of running Terraform/Terragrunt CI/CD workflows.</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="deployment_walkthrough">Deployment walkthrough</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Let’s now walk through the step-by-step process of how to create a production-grade CI/CD pipeline for your
infrastructure code, fully defined and managed as code, using the Gruntwork Infrastructure as Code Library and CircleCI
as the CI server. Although this guide uses CircleCI, the configuration can be adapted with any CI platform.</p>
</div>
<div class="paragraph">
<p>We will implement the following workflow for <code>live</code> infrastructure:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/assets/img/guides/infrastructure-cicd-pipeline/cicd-pipeline-live-repo.png" alt="cicd pipeline live repo">
</div>
<div class="title">Figure 6. CI/CD Pipeline for live infrastructure code.</div>
</div>
<div class="sect2">
<h3 id="pre_requisites">Pre-requisites</h3>
<div class="paragraph">
<p>This walkthrough has the following pre-requisites:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Gruntwork Infrastructure as Code Library</dt>
<dd>
<p>This guide uses code from the <a href="https://gruntwork.io/infrastructure-as-code-library/">Gruntwork Infrastructure as Code Library</a>, as it
implements most of the production-grade design for you out of the box. Make sure to read
<a href="/guides/foundations/how-to-use-gruntwork-infrastructure-as-code-library">How to use the Gruntwork Infrastructure as Code Library</a>.</p>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
You must be a <span class="js-subscribe-cta">Gruntwork subscriber</span> to access the Gruntwork Infrastructure as Code Library.
</td>
</tr>
</table>
</div>
</dd>
<dt class="hdlist1">Terraform</dt>
<dd>
<p>This guide uses <a href="https://www.terraform.io/">Terraform</a> to define and manage all the infrastructure as code. If you&#8217;re
not familiar with Terraform, check out <a href="https://blog.gruntwork.io/a-comprehensive-guide-to-terraform-b3d32832baca">A
Comprehensive Guide to Terraform</a>, <a href="https://training.gruntwork.io/p/terraform">A Crash Course on Terraform</a>, and
<a href="/guides/foundations/how-to-use-gruntwork-infrastructure-as-code-library">How to Use the Gruntwork Infrastructure as Code Library</a></p>
</dd>
<dt class="hdlist1">CircleCI</dt>
<dd>
<p>This guide uses <a href="https://circleci.com/">CircleCI</a> as the CI platform. Although the approach is compatible with any CI
platform, a basic understanding of the CircleCI configuration will be useful for translating the configuration format
to other platforms. You can take a look at <a href="https://circleci.com/docs/2.0/getting-started/#section=getting-started">the
official getting started guide</a> to get a basic understanding of CircleCI and their configuration format.</p>
</dd>
<dt class="hdlist1">AWS accounts</dt>
<dd>
<p>This guide deploys infrastructure into one or more AWS accounts. Check out the
<a href="/guides/foundations/how-to-configure-production-grade-aws-account-structure">Production Grade AWS Account Structure</a> guide for instructions.
You will also need to be able to authenticate to these accounts on the CLI: check out
<a href="https://blog.gruntwork.io/a-comprehensive-guide-to-authenticating-to-aws-on-the-command-line-63656a686799">A Comprehensive Guide to Authenticating to AWS on the Command Line</a>
for instructions.</p>
</dd>
<dt class="hdlist1">Repository structure</dt>
<dd>
<p>This guide assumes your infrastructure code is organized in a manner similar to that covered in the
<a href="https://gruntwork.io/guides/foundations/how-to-use-gruntwork-infrastructure-as-code-library/#using_terraform_modules">Using
Terraform Modules section of the How to Use the Gruntwork Infrastructure as Code Library</a> guide. This means that you
should have two repositories for your infrastructure code, <code>infrastructure-modules</code> and <code>infrastructure-live</code>. Make
sure that the <code>infrastructure-live</code> repository is locked down as recommended in <a href="#lock_down_vcs_systems">Lock down VCS systems</a>. This guide
will assume that <code>master</code> is the protected branch where infrastructure is deployed from.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
This guide will use <a href="https://github.com/gruntwork-io/terragrunt">Terragrunt</a> and its associated file and folder
structure to deploy Terraform modules. Please note that <strong>Terragrunt is NOT required for using Terraform modules from
the Gruntwork Infrastructure as Code Library.</strong> Check out
<a href="/guides/foundations/how-to-use-gruntwork-infrastructure-as-code-library">How to Use the Gruntwork Infrastructure as Code Library</a> for instructions
on alternative options, such as how to
<a href="/guides/foundations/how-to-use-gruntwork-infrastructure-as-code-library#deploy_using_plain_terraform">Deploy using plain Terraform</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_deploy_a_vpc">Deploy a VPC</h3>
<div class="paragraph">
<p>The first step is to deploy a VPC. Follow the instructions in
<a href="/guides/networking/how-to-deploy-production-grade-vpc-aws">How to deploy a production-grade VPC on AWS</a> to use
<code>module-vpc</code> to create a VPC setup that looks like this:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/assets/img/guides/vpc/vpc-diagram.png" alt="vpc diagram">
</div>
<div class="title">Figure 7. A production-grade VPC setup deployed using module-vpc from the Gruntwork Infrastructure as Code Library</div>
</div>
<div class="paragraph">
<p>We will use the Mgmt VPC to deploy our infrastructure deployment CD platform, since the infrastructure deployment
platform is a management infrastructure that is designed to deploy to multiple environments.</p>
</div>
<div class="paragraph">
<p>After following this guide, you should have a <code>vpc-mgmt</code> wrapper module in your <code>infrastructure-modules</code> repo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>infrastructure-modules
  └ networking
    └ vpc-mgmt
      └ main.tf
      └ outputs.tf
      └ variables.tf</pre>
</div>
</div>
<div class="paragraph">
<p>Here&#8217;s a snippet of what the code in the <code>vpc-mgmt</code> wrapper module looks like:</p>
</div>
<div class="listingblock">
<div class="title">infrastructure-modules/networking/vpc-app/main.tf</div>
<div class="content">
<pre class="highlight"><code class="language-hcl" data-lang="hcl">module "vpc" {
  # Make sure to replace &lt;VERSION&gt; in this URL with the latest module-vpc release
  source = "git@github.com:gruntwork-io/module-vpc.git//modules/vpc-mgmt?ref=&lt;VERSION&gt;"

  vpc_name         = var.vpc_name
  aws_region       = var.aws_region
  cidr_block       = var.cidr_block
  num_nat_gateways = var.num_nat_gateways
}

# ... (the rest of the code is ommitted) ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should also have a corresponding live configuration in your <code>infrastructure-live</code> repo to deploy the VPC. For
example, for your production environment, there should be a folder called <code>production</code> in the <code>infrastructure-live</code> repo
that looks as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>infrastructure-live
  └ production
    └ terragrunt.hcl
    └ us-east-2
      └ prod
        └ networking
          └ vpc-mgmt
            └ terragrunt.hcl</pre>
</div>
</div>
<div class="paragraph">
<p>Here&#8217;s a snippet of what the code in the <code>vpc-mgmt</code> Terragrunt configuration file looks like:</p>
</div>
<div class="listingblock">
<div class="title">infrastructure-live/production/us-east-2/prod/networking/vpc-mgmt/terragrunt.hcl</div>
<div class="content">
<pre class="highlight"><code class="language-hcl" data-lang="hcl"># Pull in the backend and provider configurations from a root terragrunt.hcl file that you include in each child terragrunt.hcl:
include {
  path = find_in_parent_folders()
}

# Set the source to an immutable released version of the infrastructure module being deployed:
terraform {
  source = "git@github.com/&lt;YOUR_ORG&gt;/infrastructure-modules.git//networking/vpc-mgmt?ref=v0.3.0"
}

# Configure input values for the specific environment being deployed:
inputs = {
  aws_region       = "us-east-2"
  aws_account_id   = "111122223333"
  vpc_name         = "mgmt-prod"
  cidr_block       = "10.0.0.0/16"
  num_nat_gateways = 3
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_deploy_the_ecs_deploy_runner">Deploy the ECS Deploy Runner</h3>
<div class="paragraph">
<p>For this guide, we will use
<a href="https://github.com/gruntwork-io/module-ci/blob/master/README-Terraform-Terragrunt-Pipeline.adoc">Gruntwork&#8217;s ECS Deploy
Runner stack</a> as our infrastructure deployment CD platform. We will deploy the stack into the private subnet of our
mgmt VPC using the <a href="https://github.com/gruntwork-io/module-ci/tree/master/modules/ecs-deploy-runner">ecs-deploy-runner
module</a> in <code>module-ci</code>.</p>
</div>
<div class="paragraph">
<p>To deploy the ECS Deploy Runner, we will follow three steps:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#create_ecr_repo">Create ECR repo</a></p>
</li>
<li>
<p><a href="#create_docker_image">Create Docker Image</a></p>
</li>
<li>
<p><a href="#deploy_ecs_deploy_runner_stack">Deploy ECS Deploy Runner stack</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="create_ecr_repo">Create ECR repo</h4>
<div class="paragraph">
<p>The ECS Deploy Runner uses an ECS Task to run the infrastructure deployment. In order to run the ECS task, we need a
Docker image that contains all the necessary software for the deployment, as well as an ECR repository to store that
Docker image. We will start by creating the ECR repo.</p>
</div>
<div class="paragraph">
<p>Create a new module called <code>ecr-repo</code> in <code>infrastructure-modules</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>infrastructure-modules
  └ cicd
    └ ecr-repo
      └ main.tf
      └ outputs.tf
      └ variables.tf
  └ networking
    └ vpc-mgmt
      └ main.tf
      └ outputs.tf
      └ variables.tf</pre>
</div>
</div>
<div class="paragraph">
<p>Inside of <code>main.tf</code>, configure the ECR repository:</p>
</div>
<div class="listingblock">
<div class="title">infrastructure-modules/cicd/ecr-repo/main.tf</div>
<div class="content">
<pre class="highlight"><code class="language-hcl" data-lang="hcl">resource "aws_ecr_repository" "repo" {
  name                 = var.name

  image_scanning_configuration {
    scan_on_push = true
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This defines a new ECR repository with a name configured by an input variable and indicates that images should be
scanned automatically on push.</p>
</div>
<div class="paragraph">
<p>Add the corresponding <code>name</code> variable to <code>variables.tf</code>:</p>
</div>
<div class="listingblock">
<div class="title">infrastructure-modules/cicd/ecr-repo/variables.tf</div>
<div class="content">
<pre class="highlight"><code class="language-hcl" data-lang="hcl">variable "name" {
  description = "The name of the ECR repository to be created."
  type        = string
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Also make sure that the repository URL is exposed in <code>outputs.tf</code>, as we will need it later when deploying the ECS
Deploy Runner:</p>
</div>
<div class="listingblock">
<div class="title">infrastructure-modules/cicd/ecr-repo/outputs.tf</div>
<div class="content">
<pre class="highlight"><code class="language-hcl" data-lang="hcl">output "url" {
  description = "The Docker URL for the created ECR repository. This can be used as the push URL for containers."
  value       = aws_ecr_repository.repo.repository_url
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>At this point, you&#8217;ll want to test your code. See
<a href="/guides/foundations/how-to-use-gruntwork-infrastructure-as-code-library#manual_tests_terraform">Manual tests for Terraform code</a>
and
<a href="/guides/foundations/how-to-use-gruntwork-infrastructure-as-code-library#automated_tests_terraform">Automated tests for Terraform code</a>
for instructions.</p>
</div>
<div class="paragraph">
<p>Once your <code>ecr-repo</code> module is working the way you want, submit a pull request, get your changes merged into the
<code>master</code> branch, and create a new versioned release by using a Git tag. For example, to create a <code>v0.5.0</code> release:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">git tag -a "v0.5.0" -m "Added module for creating ECR repositories"
git push --follow-tags</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now that we have a module for managing an ECR repo, head over to your <code>infrastructure-live</code> repo and add a
<code>terragrunt.hcl</code> file for creating the ECR repo for the ECS deploy runner:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>infrastructure-live
  └ production
    └ terragrunt.hcl
    └ us-east-2
      └ prod
        └ cicd
          └ ecr-repo
            └ terragrunt.hcl
        └ networking
          └ vpc-mgmt
            └ terragrunt.hcl</pre>
</div>
</div>
<div class="listingblock">
<div class="title">infrastructure-live/production/us-east-2/prod/cicd/ecr-repo/terragrunt.hcl</div>
<div class="content">
<pre class="highlight"><code class="language-hcl" data-lang="hcl"># Pull in the backend and provider configurations from a root terragrunt.hcl file that you include in each child terragrunt.hcl:
include {
  path = find_in_parent_folders()
}

# Set the source to an immutable released version of the infrastructure module being deployed:
terraform {
  source = "git@github.com/&lt;YOUR_ORG&gt;/infrastructure-modules.git//cicd/ecr-repo?ref=v0.5.0"
}

# Configure input values for the specific environment being deployed:
inputs = {
  name = "ecs-deploy-runner"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And run <code>terragrunt apply</code> to deploy the changes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">cd infrastructure-live/production/us-east-2/prod/cicd/ecr-repo
terragrunt apply</code></pre>
</div>
</div>
<div class="paragraph">
<p>Make sure to note the repository URL. You can store it in an environment variable for easy reference when building the
Docker image:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">cd infrastructure-live/production/us-east-2/prod/cicd/ecr-repo
export ECR_REPO_URL=$(terragrunt output url)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="create_docker_image">Create Docker Image</h4>
<div class="paragraph">
<p>Once we have the ECR repository to house Docker images, we need to create the Docker image for the infrastructure
deployer. This Docker image should contain everything you need to deploy your infrastructure, such as <code>terraform</code> and
<code>terragrunt</code>. In addition, the Docker image should include the
<a href="https://github.com/gruntwork-io/module-ci/tree/master/modules/infrastructure-deploy-script">infrastructure-deploy-script</a>.
This is a python script that does the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Clone the repository containing the infrastructure code using git.</p>
</li>
<li>
<p>Change the working directory to the desired path passed in the parameters.</p>
</li>
<li>
<p>Run <code>terraform</code> or <code>terragrunt</code> with <code>plan</code> or <code>apply</code> depending on the passed in parameters, streaming the output to
<code>stdout</code> and <code>stderr</code>.</p>
</li>
<li>
<p>Exit with the appropriate exit code depending on if the underlying command succeeded or failed.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Create a placeholder module called <code>ecs-deploy-runner</code> in <code>infrastructure-modules</code>, with a folder <code>docker</code> with the
<code>Dockerfile</code> for creating the Docker image and the <code>known_hosts</code> file. Copy over the <code>Dockerfile</code> and <code>known_hosts</code> file
from <a href="https://github.com/gruntwork-io/module-ci/tree/master/modules/ecs-deploy-runner/docker">module-ci</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>infrastructure-modules
  └ cicd
    └ ecs-deploy-runner
      └ docker
        └ Dockerfile
        └ known_hosts
    └ ecr-repo
      └ main.tf
      └ outputs.tf
      └ variables.tf
  └ networking
    └ vpc-mgmt
      └ main.tf
      └ outputs.tf
      └ variables.tf</pre>
</div>
</div>
<div class="paragraph">
<p>This <code>Dockerfile</code> includes various tools and utilities that are necessary for deploying anything from the Gruntwork
Infrastructure as Code Library. You should modify this <code>Dockerfile</code> to include additional tools that are necessary for
your environment.</p>
</div>
<div class="paragraph">
<p>Next, build the Docker image locally:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">cd infrastructure-modules/cicd/ecs-deploy-runner/docker
# Make sure you have set the environment variable GITHUB_OAUTH_TOKEN with a GitHub personal access token that has access
# to the Gruntwork repositories
docker build --build-arg GITHUB_OAUTH_TOKEN --tag "$ECR_REPO_URL:v1" .</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, push the Docker image to the ECR repository so that it is available to ECS:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"># Authenticate docker so that you can access the ECR Repository
eval "$(aws ecr get-login --region "us-east-2" --no-include-email)"
docker push "$ECR_REPO_URL:v1"</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="deploy_ecs_deploy_runner_stack">Deploy ECS Deploy Runner stack</h4>
<div class="paragraph">
<p>Once we have the ECR repo with an available Docker image, it is time to configure the ECS task and Lambda function
invoker. We will deploy both using the
<a href="https://github.com/gruntwork-io/module-ci/tree/master/modules/ecs-deploy-runner">ecs-deploy-runner module</a> in
<code>module-ci</code>.</p>
</div>
<div class="paragraph">
<p>Add the Terraform files for the <code>ecs-deploy-runner</code> in <code>infrastructure-modules</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>infrastructure-modules
  └ cicd
    └ ecs-deploy-runner
      └ docker
        └ Dockerfile
        └ known_hosts
      └ main.tf
      └ variables.tf
    └ ecr-repo
      └ main.tf
      └ outputs.tf
      └ variables.tf
  └ networking
    └ vpc-mgmt
      └ main.tf
      └ outputs.tf
      └ variables.tf</pre>
</div>
</div>
<div class="paragraph">
<p>Inside of <code>main.tf</code>, configure the ECS Deploy Runner:</p>
</div>
<div class="listingblock">
<div class="title">infrastructure-modules/cicd/ecs-deploy-runner/main.tf</div>
<div class="content">
<pre class="highlight"><code class="language-hcl" data-lang="hcl">module "ecs_deploy_runner" {
  # Make sure to replace &lt;VERSION&gt; in this URL with the latest module-ci release
  source = "git::git@github.com:gruntwork-io/module-ci.git//modules/ecs-deploy-runner?ref=&lt;VERSION&gt;"

  name            = var.name
  container_image = var.container_image
  vpc_id          = var.vpc_id
  vpc_subnet_ids  = var.private_subnet_ids

  repository                          = var.repository
  ssh_private_key_secrets_manager_arn = var.ssh_private_key_secrets_manager_arn
}

# ---------------------------------------------------------------------------------------------------------------------
# CREATE IAM POLICY WITH PERMISSIONS TO INVOKE THE ECS DEPLOY RUNNER VIA THE LAMBDA FUNCTION AND ATTACH TO USERS
# ---------------------------------------------------------------------------------------------------------------------

module "invoke_policy" {
  # Make sure to replace &lt;VERSION&gt; in this URL with the latest module-ci release
  source = "git::git@github.com:gruntwork-io/module-ci.git//modules/ecs-deploy-runner-invoke-iam-policy?ref=&lt;VERSION&gt;"

  name                                      = "invoke-${var.name}"
  deploy_runner_invoker_lambda_function_arn = module.ecs_deploy_runner.invoker_function_arn
  deploy_runner_ecs_cluster_arn             = module.ecs_deploy_runner.ecs_cluster_arn
  deploy_runner_cloudwatch_log_group_name   = module.ecs_deploy_runner.cloudwatch_log_group_name
}

resource "aws_iam_role_policy_attachment" "attach_invoke_to_roles" {
  for_each   = length(var.iam_roles) &gt; 0 ? { for k in var.iam_roles : k =&gt; k } : {}
  role       = each.key
  policy_arn = module.invoke_policy.arn
}


# ---------------------------------------------------------------------------------------------------------------------
# ATTACH FULL ACCESS PERMISSIONS TO REQUESTED SERVICES TO ECS TASK
# ---------------------------------------------------------------------------------------------------------------------

resource "aws_iam_role_policy" "full_access_to_services" {
  count  = length(var.permitted_services) &gt; 0 ? 1 : 0
  name   = "full-access-to-services"
  role   = module.ecs_deploy_runner.ecs_task_iam_role_name
  policy = data.aws_iam_policy_document.full_access_to_services.json
}

data "aws_iam_policy_document" "full_access_to_services" {
  statement {
    actions   = formatlist("%s:*", var.permitted_services)
    resources = ["*"]
    effect    = "Allow"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This module call does the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Create an ECS cluster that can be used to run ECS Fargate tasks</p>
</li>
<li>
<p>Deploy an ECS Task Definition for the provided container image with support for Fargate (<code>var.container_image</code>).</p>
</li>
<li>
<p>Configure the ECS Task to expose the secrets in the Secrets Manager entry with the ARN
<code>var.ssh_private_key_secrets_manager_arn</code> as environment variables.</p>
</li>
<li>
<p>Deploy a Lambda function that is configured to invoke the ECS task to run on Fargate in the provided VPC and subnet
(<code>var.vpc_id</code> and <code>var.private_subnet_ids</code>).
Restrict the interface so that it can only be triggered to deploy code from the configured git repository
(<code>var.repository</code>).</p>
</li>
<li>
<p>Grant permissions to invoke the Invoker Lambda function to the given list of IAM users.</p>
</li>
<li>
<p>Grant permissions to access the provided AWS services to the ECS Task.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Add the corresponding input variables to <code>variables.tf</code>:</p>
</div>
<div class="listingblock">
<div class="title">infrastructure-modules/cicd/ecs-deploy-runner/variables.tf</div>
<div class="content">
<pre class="highlight"><code class="language-hcl" data-lang="hcl">variable "vpc_id" {
  description = "ID of the VPC where the ECS task and Lambda function should run."
  type        = string
}

variable "private_subnet_ids" {
  description = "List of IDs of private subnets that can be used for running the ECS task and Lambda function."
  type        = list(string)
}

variable "container_image" {
  description = "Docker image (repo and tag) to use for the ECS task. Should contain the infrastructure-deploy-script for the pipeline to work. Refer to the Dockerfile in /modules/ecs-deploy-runner/docker/Dockerfile for a sample container you can use."
  type = object({
    repo = string
    tag  = string
  })
}

variable "repository" {
  description = "Git repository where source code is located."
  type        = string
}

variable "ssh_private_key_secrets_manager_arn" {
  description = "ARN of the AWS Secrets Manager entry to use for sourcing the SSH private key for cloning repositories. Set to null if you are only using public repos."
  type        = string
}

variable "name" {
  description = "Name of this instance of the deploy runner stack. Used to namespace all resources."
  type        = string
  default     = "ecs-deploy-runner"
}

variable "iam_roles" {
  description = "List of AWS IAM roles that should be given access to invoke the deploy runner."
  type        = list(string)
  default     = []
}

variable "permitted_services" {
  description = "A list of AWS services for which the Deploy Runner ECS Task will receive full permissions. For example, to grant the deploy runner access only to EC2 and Amazon Machine Learning, use the value [\"ec2\",\"machinelearning\"]."
  type        = list(string)
  default     = []
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since all the lookups for the ECS Deploy Runner can be done by name, it is not necessary for this module to expose any
outputs.</p>
</div>
<div class="paragraph">
<p>Once you test your code and the <code>ecs-deploy-runner</code> module is working the way you want, submit a
pull request, get your changes merged into the <code>master</code> branch, and create a new versioned release by using a Git tag.</p>
</div>
<div class="paragraph">
<p>Next, we will want to deploy the stack to the environments. Before deploying, we need to make sure we have a SSH key
pair we can use to access our private repositories:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create a machine user on your version control platform.</p>
</li>
<li>
<p>Create a new SSH key pair on the command line using
<code>ssh-keygen</code>:</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre>ssh-keygen -t rsa -b 4096 -C "MACHINE_USER_EMAIL"</pre>
</div>
</div>
<div class="paragraph">
<p>Make sure to set a different path to store the key (to avoid overwriting any existing key). Also avoid setting a
passphrase on the key.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Upload the SSH key pair to the machine user. See the following docs for the major VCS platforms:</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://help.github.com/en/github/authenticating-to-github/adding-a-new-ssh-key-to-your-github-account">GitHub</a></p>
</li>
<li>
<p><a href="https://docs.gitlab.com/ee/ssh/README.html#adding-an-ssh-key-to-your-gitlab-account">GitLab</a></p>
</li>
<li>
<p><a href="https://confluence.atlassian.com/bitbucket/set-up-an-ssh-key-728138079.html#SetupanSSHkey-#installpublickeyStep3.AddthepublickeytoyourBitbucketsettings">BitBucket</a> (Note: you will need to expand one of the instructions to see the full instructions for adding an SSH key to the machine user account)</p>
</li>
</ul>
</div>
</li>
<li>
<p>Create an AWS Secrets Manager entry with the contents of the private key. In the following example, we use the aws
CLI to create the entry in <code>us-east-2</code>, sourcing the contents from the SSH private key file <code>~/.ssh/machine_user</code>:</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre>cat ~/.ssh/machine_user \
    | xargs -0 aws secretsmanager create-secret --region us-east-2 --name "SSHPrivateKeyForECSDeployRunner" --secret-string</pre>
</div>
</div>
<div class="paragraph">
<p>When you run this command, you should see a JSON output with metadata about the created secret:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
    "ARN": "arn:aws:secretsmanager:us-east-2:000000000000:secret:SSHPrivateKeyForECSDeployRunner-SOME_RANDOM_STRING",
    "Name": "SSHPrivateKeyForECSDeployRunner",
    "VersionId": "21cda90e-84e0-4976-8914-7954cb6151bd"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, head over to your <code>infrastructure-live</code> repo to deploy the stack to your environments. Add a new
<code>terragrunt.hcl</code> file that calls the module. We will use Terragrunt <code>dependency</code> blocks to get the outputs of our
dependencies to pass them to the module:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>infrastructure-live
  └ production
    └ terragrunt.hcl
    └ us-east-2
      └ prod
        └ cicd
          └ ecr-repo
            └ terragrunt.hcl
          └ ecs-deploy-runner
            └ terragrunt.hcl
        └ networking
          └ vpc-mgmt
            └ terragrunt.hcl</pre>
</div>
</div>
<div class="listingblock">
<div class="title">infrastructure-live/production/us-east-2/prod/cicd/ecs-deploy-runner/terragrunt.hcl</div>
<div class="content">
<pre class="highlight"><code class="language-hcl" data-lang="hcl"># Pull in the backend and provider configurations from a root terragrunt.hcl file that you include in each child terragrunt.hcl:
include {
  path = find_in_parent_folders()
}

# Set the source to an immutable released version of the infrastructure module being deployed:
terraform {
  source = "git@github.com/&lt;YOUR_ORG&gt;/infrastructure-modules.git//cicd/ecr-repo?ref=v0.5.0"
}

# Look up the VPC and ECR repository information using dependency blocks:
dependency "vpc" {
  config_path = "${get_terragrunt_dir()}/../../networking/vpc-mgmt"
}
dependency "ecr" {
  config_path = "${get_terragrunt_dir()}/../ecr-repo"
}

# Configure input values for the specific environment being deployed:
inputs = {
  vpc_id             = dependency.vpc.outputs.vpc_id
  private_subnet_ids = dependency.vpc.outputs.vpc_id

  container_image = {
    repo = dependency.ecr.outputs.url
    tag  = "v1"
  }

  repository = "git@github.com:&lt;YOUR_ORG&gt;/infrastructure-live.git"

  # Set this to the Secrets Manager ARN that was outputted when you created the Secrets Manager entry.
  ssh_private_key_secrets_manager_arn = "ARN_TO_SECRETS_MANAGER_WITH_SSH_PRIVATE_KEY"

  # Set this to the AWS IAM role that your machine user will assume.
  iam_roles = ["allow-auto-deploy-from-other-accounts"]
  # This list should include all the services that you want this ECS deploy runner to manage.
  permitted_services = [
    "iam",
    "s3",
    "lambda",
    "apigateway",
    "dynamodb",
  ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And run <code>terragrunt apply</code> to deploy the changes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">cd infrastructure-live/production/us-east-2/prod/cicd/ecs-deploy-runner
terragrunt apply</code></pre>
</div>
</div>
<div class="paragraph">
<p>Repeat for each environment that you want to support the ECS Deploy Runner stack.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_try_out_the_ecs_deploy_runner">Try out the ECS Deploy Runner</h3>
<div class="paragraph">
<p>At this point, you can see if the ECS Deploy Runner can be used to deploy your infrastructure. To test, use the
<a href="https://github.com/gruntwork-io/module-ci/tree/master/modules/infrastructure-deployer">infrastructure-deployer CLI</a>.</p>
</div>
<div class="paragraph">
<p>To use the <code>infrastructure-deployer</code> CLI, use <code>gruntwork-install</code> to install a precompiled version for your system:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"># Update &lt;VERSION&gt; to the latest version of module-ci
gruntwork-install --binary-name "infrastructure-deployer" --repo "https://github.com/gruntwork-io/module-ci" --tag "&lt;VERSION&gt;"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, invoke the <code>infrastructure-deployer</code> against the <code>master</code> branch of your live infrastructure to run a <code>plan</code> on
the <code>vpc-mgmt</code> module (don&#8217;t forget to assume the role):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"># NOTE: you should assume the IAM role allow-auto-deploy-from-other-accounts before running this step
infrastructure-deployer \
  --aws-region "us-east-2" \
  --ref "master" \
  --binary "terragrunt" \
  --command "plan" \
  --deploy-path "production/us-east-2/prod/networking/vpc-mgmt"</code></pre>
</div>
</div>
<div class="paragraph">
<p>If everything is set up correctly, you should see a stream of logs that indicate a <code>terragrunt plan</code> running on the
<code>vpc-mgmt</code> module.</p>
</div>
</div>
<div class="sect2">
<h3 id="define_pipeline_as_code">Define pipeline as code</h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
This guide will use <a href="https://circleci.com/">CircleCI</a> as the CI server, but <strong>it is NOT required for using the ECS
Deploy Runner stack</strong>. You can configure any other CI server in a similar fashion to invoke deployments against the ECS
Deploy Runner.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now that we have a working ECS Deploy Runner stack, the final step is to configure our CI/CD pipeline in our CI server
of choice. For this guide, we will configure CircleCI to implement the workflow described at the beginning of this
section.</p>
</div>
<div class="paragraph">
<p>Create the CircleCI configuration folder in your <code>infrastructure-live</code> repo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>infrastructure-live
  └ .circleci
    └ config.yml
    └ deploy.sh
    └ install.sh
  └ production
    └ terragrunt.hcl
    └ us-east-2
      └ prod
        └ cicd
          └ ecr-repo
            └ terragrunt.hcl
          └ ecs-deploy-runner
            └ terragrunt.hcl
        └ networking
          └ vpc-mgmt
            └ terragrunt.hcl</pre>
</div>
</div>
<div class="paragraph">
<p>The scripts <code>deploy.sh</code> and <code>install.sh</code> are helper scripts to make the CircleCI configuration more readable. Here are
the contents of the scripts:</p>
</div>
<div class="listingblock">
<div class="title">infrastructure-live/.circleci/install.sh</div>
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">#!/bin/bash
#
# Script used by CircleCI to install the necessary helpers for the CI/CD pipeline
#
# Required environment variables:
# - GRUNTWORK_INSTALLER_VERSION : The version of the gruntwork-installer helper utility used to install scripts from the
#                                 Gruntwork IaC Library.
# - MODULE_CI_VERSION : The version of the module-ci repository to use when installing the terraform helpers and
#                       infrastructure-deployer CLI.
# - MODULE_SECURITY_VERSION : The version of the module-security repository to use when installing the aws-auth utility.
#

set -e

function run {
  local -r gruntwork_installer_version="$1"
  local -r module_ci_version="$2"
  local -r module_security_version="$3"

  curl -Ls https://raw.githubusercontent.com/gruntwork-io/gruntwork-installer/master/bootstrap-gruntwork-installer.sh \
    | bash /dev/stdin --version "$gruntwork_installer_version"
  gruntwork-install --repo "https://github.com/gruntwork-io/module-ci" \
    --binary-name "infrastructure-deployer" \
    --tag "$module_ci_version"
  gruntwork-install --repo "https://github.com/gruntwork-io/module-ci" \
    --module-name "terraform-helpers" \
    --tag "$module_ci_version"
  gruntwork-install --repo "https://github.com/gruntwork-io/module-security" \
    --module-name "aws-auth" \
    --tag "$module_security_version"
}

run "${GRUNTWORK_INSTALLER_VERSION}" "${MODULE_CI_VERSION}" "${MODULE_SECURITY_VERSION}"</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">infrastructure-live/.circleci/deploy.sh</div>
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">#!/bin/bash
#
# Script used by CircleCI to trigger deployments via the infrastructure-deployer CLI utility.
#
# Required environment variables:
# - REGION : The AWS Region where the ECS Deploy Runner exists.
# - SOURCE_REF : The starting point for identifying all the changes. The diff between SOURCE_REF and REF will be
#                evaluated to determine all the changed files.
# - REF : The end point for identifying all the changes. The diff between SOURCE_REF and REF will be evaluated to
#         determine all the changed files.
# - COMMAND : The command to run. Should be one of plan or apply.
#

set -e

# A function that uses aws-auth to assume the IAM role for invoking the ECS Deploy Runner.
function assume_role_for_environment {
  local -r environment="$1"

  # NOTE: Make sure to set the respective ACCOUNT_ID to the AWS account ID for each of the environments.
  if [[ "$environment" == "production" ]]; then
    aws-auth --role-arn "arn:aws:iam::&lt;PRODUCTION_ACCOUNT_ID&gt;:role/allow-auto-deploy-from-other-accounts
  elif [[ "$environment" == "staging" ]]; then
    aws-auth --role-arn "arn:aws:iam::&lt;STAGING_ACCOUNT_ID&gt;:role/allow-auto-deploy-from-other-accounts
  else
    echo "ERROR: Unknown environment $environment. Can not assume role."
    exit 1
  fi
}

# Function that invoke the ECS Deploy Runner using the infrastructure-deployer CLI. This will also make sure to assume
# the correct IAM role based on the deploy path.
function invoke_infrastructure_deployer {
  local -r region="$1"
  local -r ref="$2"
  local -r command="$3"
  local -r deploy_path="$4"

  local assume_role_exports
  if [[ $deploy_path =~ ^([^/]+)/.+$ ]]; then
    assume_role_exports="$(assume_role_for_environment "${BASH_REMATCH[1]}")"
  else
    echo "ERROR: Could not extract environment from deployment path $deploy_path."
    exit 1
  fi

  (eval "$assume_role_exports" &amp;&amp; \
    infrastructure-deployer --aws-region "$region" --ref "$ref" --binary "terragrunt" --command "$command" --deploy-path "$deploy_path")
}

function run {
  local -r region="$1"
  local -r source_ref="$2"
  local -r ref="$3"
  local -r command="$4"

  # We must export the functions so that they can be invoked through xargs
  export -f invoke_infrastructure_deployer
  export -f assume_role_for_environment

  # Use git-updated-folders to find all the terragrunt modules that changed, and pipe that through to the
  # infrastructure-deployer.
  # NOTE: the tee in the middle of the pipeline is used so we can see the detected folders that were updated in the
  # logs. The last step is a check to see if there was any output from the previous command, which will be empty if no
  # modules were updated.
  git-updated-folders --source-ref "$source_ref" --terragrunt \
    | tee /dev/tty \
    | xargs -L1 --no-run-if-empty \
        invoke_infrastructure_deployer "$region" "$ref" "$command"
    |&amp; grep . || echo "No terragrunt modules were updated. Skipping plan."
}

run "${REGION}" "${SOURCE_REF}" "${REF}" "$@"</code></pre>
</div>
</div>
<div class="paragraph">
<p>We will call out to these scripts in the CI pipeline to setup our environment for the deployments. With the scripts
defined, let&#8217;s start building out our CircleCI config. We will start by defining the workflows, which acts as the basis
of our pipeline:</p>
</div>
<div class="listingblock">
<div class="title">infrastructure-live/.circleci/config.yml</div>
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">version: 2.1

workflows:
  continuous-deploy:
    jobs:
      - plan

      - notify:
          requires:
            - plan
          filters:
            branches:
              only: master

      - hold:
          type: approval
          requires:
            - notify
          filters:
            branches:
              only: master

      - deploy:
          requires:
            - hold
          filters:
            branches:
              only: master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Our workflow consists of four steps:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>plan</code>: Run <code>terragrunt plan</code> on all the files that changed. This is run on commits to all branches.</p>
</li>
<li>
<p><code>notify</code>: Notify on slack that there is an approval available for review. This should only run on <code>master</code> (our
deployment branch). The rest of the pipeline will also only be restricted to commits on <code>master</code>.</p>
</li>
<li>
<p><code>hold</code>: The approval stage. We will hold all deployments for approval after running plan, but before proceeding to
running <code>terragrunt apply</code> so that an admin has a chance to review the exact changes that are about to be
rolled out.</p>
</li>
<li>
<p><code>deploy</code>: Run <code>terragrunt apply</code> on all the files that changed. This should only happen after approval.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Next, we will update our config to start defining the jobs. Since all the jobs will have common elements, we will
define a few aliases in the config to reuse common components.</p>
</div>
<div class="paragraph">
<p>The first is the runtime environment of each job:</p>
</div>
<div class="listingblock">
<div class="title">infrastructure-live/.circleci/config.yml</div>
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml"># Global constants for the jobs. This includes:
# - Using machine executor
# - Tools versions
defaults: &amp;defaults
  machine:
    image: "ubuntu-1604:201903-01"
  environment:
    GRUNTWORK_INSTALLER_VERSION: v0.0.22
    MODULE_CI_VERSION: v0.17.0
    MODULE_SECURITY_VERSION: v0.24.1
    REGION: us-east-2</code></pre>
</div>
</div>
<div class="paragraph">
<p>We will also want to figure out a friendly name for the deployment. CircleCI gives us a few environment variables that
are related to the commit that has triggered the build, but for notification purposes we would like to know whether the
build is a tag, branch, or SHA. The following routine updates the runtime with the environment variable
<code>CIRCLE_FRIENDLY_REF</code> which tells us whether the change was a tag, branch, or bare commit:</p>
</div>
<div class="listingblock">
<div class="title">infrastructure-live/.circleci/config.yml</div>
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml"># This common step is used to determine the user friendly Git Ref name of the build, either the branch or tag.
set_friendly_git_ref: &amp;set_friendly_git_ref
  run:
    name: set friendly git ref name
    command: |
      if [[ ! -z "$CIRCLE_TAG" ]]; then
        echo 'export CIRCLE_FRIENDLY_REF="$CIRCLE_TAG"' &gt;&gt; $BASH_ENV
      elif [[ ! -z "$CIRCLE_BRANCH" ]]; then
        echo 'export CIRCLE_FRIENDLY_REF="$CIRCLE_BRANCH"' &gt;&gt; $BASH_ENV
      else
        echo 'export CIRCLE_FRIENDLY_REF="$CIRCLE_SHA1"' &gt;&gt; $BASH_ENV
      fi</code></pre>
</div>
</div>
<div class="paragraph">
<p>We also need to know what the base comparison point is for finding updated modules. We will set this as the environment
variable <code>SOURCE_REF</code> in the runtime environment:</p>
</div>
<div class="listingblock">
<div class="title">infrastructure-live/.circleci/config.yml</div>
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml"># This is used to determine what to use as the base comparison point for determining what modules to deploy. The logic
# is as follows:
#   - If we are on the master branch, the comparison is only the current commit.
#   - If we are not on master, the comparison is to the current state of the master branch.
set_source_ref: &amp;set_source_ref
  run:
    name: set source ref
    command: |
      if [[ "$CIRCLE_BRANCH" == "master" ]]; then
        echo 'export SOURCE_REF=HEAD^' &gt;&gt; $BASH_ENV
      else
        # We have to use origin/master because the checkout routine in CircleCI sets the local master to HEAD.
        echo 'export SOURCE_REF=origin/master' &gt;&gt; $BASH_ENV
      fi</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, we need to import functionality to notify on Slack. We will use the
<a href="https://github.com/CircleCI-Public/slack-orb">official Slack Orb</a> from CircleCI:</p>
</div>
<div class="listingblock">
<div class="title">infrastructure-live/.circleci/config.yml</div>
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">orbs:
  slack: circleci/slack@3.4.2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once we have the common elements defined as aliases, we can start defining each of the jobs. We will start with the
<code>plan</code> job:</p>
</div>
<div class="listingblock">
<div class="title">infrastructure-live/.circleci/config.yml</div>
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">  plan:
    &lt;&lt;: *defaults
    steps:
      - &lt;&lt;: *set_friendly_git_ref
      - &lt;&lt;: *set_source_ref
      - checkout
      - run:
          name: install utilities
          command: ./.circleci/install.sh
      - run:
          name: run plan
          command: ./.circleci/deploy.sh plan
      - slack/status:
          channel: workflow-approvals
          success_message: "PLAN from $CIRCLE_FRIENDLY_REF ($CIRCLE_SHA1) successful. Click 'Visit Job' to see output."
          failure_message: "PLAN from $CIRCLE_FRIENDLY_REF ($CIRCLE_SHA1) failed. Click 'Visit Job' to see output."</code></pre>
</div>
</div>
<div class="paragraph">
<p>This job will do the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Set common environment variables for knowing a friendly name for the git ref that triggered the change and the source
ref for the changes.</p>
</li>
<li>
<p>Checkout the code in the repository.</p>
</li>
<li>
<p>Call <code>install.sh</code> which will install gruntwork utilities necessary for invoking a deployment.</p>
</li>
<li>
<p>Call <code>deploy.sh</code> which will use the <code>git-updated-folders</code> and <code>infrastructure-deployer</code> utilities to run plan on the
updated modules.</p>
</li>
<li>
<p>Notify in the <code>workflow-approvals</code> slack channel whether the plan was successful or had failed.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Next, we will define the <code>deploy</code> job, which will closely resemble the <code>plan</code> job:</p>
</div>
<div class="listingblock">
<div class="title">infrastructure-live/.circleci/config.yml</div>
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">  deploy:
    &lt;&lt;: *defaults
    steps:
      - &lt;&lt;: *set_friendly_git_ref
      - &lt;&lt;: *set_source_ref
      - slack/notify:
          channel: workflow-approvals
          message: "A deployment was approved by $CIRCLE_USERNAME for $CIRCLE_FRIENDLY_REF ($CIRCLE_SHA1). Click 'Visit Job' to see output."
      - checkout
      - run:
          name: install utilities
          command: ./.circleci/install.sh
      - run:
          name: run apply
          command: ./.circleci/deploy.sh apply
      - slack/status:
          channel: workflow-approvals
          success_message: "APPLY from $CIRCLE_FRIENDLY_REF ($CIRCLE_SHA1) was successful. Click 'Visit Job' to see output."
          failure_message: "APPLY from $CIRCLE_FRIENDLY_REF ($CIRCLE_SHA1) failed. Click 'Visit Job' to see output."</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is very similar to the <code>plan</code> job, with two differences:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Before invoking the deployment, send a message to the <code>workflow-approvals</code> slack channel indicating that a deployment
had started in response to an approval event.</p>
</li>
<li>
<p>Call <code>apply</code> instead of <code>plan</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Finally, we define the jobs for the approval notifications:</p>
</div>
<div class="listingblock">
<div class="title">infrastructure-live/.circleci/config.yml</div>
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">  notify:
    &lt;&lt;: *defaults
    steps:
      - &lt;&lt;: *set_friendly_git_ref
      - slack/approval:
          channel: workflow-approvals
          message: "A deployment for $CIRCLE_FRIENDLY_REF ($CIRCLE_SHA1) is pending approval. Click 'Visit Workflow' to approve."</code></pre>
</div>
</div>
<div class="paragraph">
<p>This job will send a message to the <code>workflow-approvals</code> slack channel that there is a deployment that is pending
approval.</p>
</div>
<div class="paragraph">
<p>For convenience, here is the full configuration in its entirety, with a few components reorganized for readability:</p>
</div>
<div class="listingblock">
<div class="title">infrastructure-live/.circleci/config.yml</div>
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">version: 2.1

workflows:
  continuous-deploy:
    jobs:
      - plan

      - notify:
          requires:
            - plan
          filters:
            branches:
              only: master

      - hold:
          type: approval
          requires:
            - notify
          filters:
            branches:
              only: master

      - deploy:
          requires:
            - hold
          filters:
            branches:
              only: master

orbs:
  slack: circleci/slack@3.4.2

# Global constants for the jobs. This includes:
# - Using machine executor
# - Tools versions
defaults: &amp;defaults
  machine:
    image: "ubuntu-1604:201903-01"
  environment:
    GRUNTWORK_INSTALLER_VERSION: v0.0.22
    MODULE_CI_VERSION: v0.17.0
    MODULE_SECURITY_VERSION: v0.24.1
    REGION: us-east-2

# This common step is used to determine the user friendly Git Ref name of the build, either the branch or tag.
set_friendly_git_ref: &amp;set_friendly_git_ref
  run:
    name: set friendly git ref name
    command: |
      if [[ ! -z "$CIRCLE_TAG" ]]; then
        echo 'export CIRCLE_FRIENDLY_REF="$CIRCLE_TAG"' &gt;&gt; $BASH_ENV
      elif [[ ! -z "$CIRCLE_BRANCH" ]]; then
        echo 'export CIRCLE_FRIENDLY_REF="$CIRCLE_BRANCH"' &gt;&gt; $BASH_ENV
      else
        echo 'export CIRCLE_FRIENDLY_REF="$CIRCLE_SHA1"' &gt;&gt; $BASH_ENV
      fi

# This is used to determine what to use as the base comparison point for determining what modules to deploy. The logic
# is as follows:
#   - If we are on the master branch, the comparison is only the current commit.
#   - If we are not on master, the comparison is to the current state of the master branch.
set_source_ref: &amp;set_source_ref
  run:
    name: set source ref
    command: |
      if [[ "$CIRCLE_BRANCH" == "master" ]]; then
        echo 'export SOURCE_REF=HEAD^' &gt;&gt; $BASH_ENV
      else
        # We have to use origin/master because the checkout routine in CircleCI sets the local master to HEAD.
        echo 'export SOURCE_REF=origin/master' &gt;&gt; $BASH_ENV
      fi

jobs:
  plan:
    &lt;&lt;: *defaults
    steps:
      - &lt;&lt;: *set_friendly_git_ref
      - &lt;&lt;: *set_source_ref
      - checkout
      - run:
          name: install utilities
          command: ./.circleci/install.sh
      - run:
          name: run plan
          command: ./.circleci/deploy.sh plan
      - slack/status:
          channel: workflow-approvals
          success_message: "PLAN from $CIRCLE_FRIENDLY_REF ($CIRCLE_SHA1) successful. Click 'Visit Job' to see output."
          failure_message: "PLAN from $CIRCLE_FRIENDLY_REF ($CIRCLE_SHA1) failed. Click 'Visit Job' to see output."
  deploy:
    &lt;&lt;: *defaults
    steps:
      - &lt;&lt;: *set_friendly_git_ref
      - &lt;&lt;: *set_source_ref
      - slack/notify:
          channel: workflow-approvals
          message: "A deployment was approved by $CIRCLE_USERNAME for $CIRCLE_FRIENDLY_REF ($CIRCLE_SHA1). Click 'Visit Job' to see output."
      - checkout
      - run:
          name: install utilities
          command: ./.circleci/install.sh
      - run:
          name: run apply
          command: ./.circleci/deploy.sh apply
      - slack/status:
          channel: workflow-approvals
          success_message: "APPLY from $CIRCLE_FRIENDLY_REF ($CIRCLE_SHA1) was successful. Click 'Visit Job' to see output."
          failure_message: "APPLY from $CIRCLE_FRIENDLY_REF ($CIRCLE_SHA1) failed. Click 'Visit Job' to see output."
  notify:
    &lt;&lt;: *defaults
    steps:
      - &lt;&lt;: *set_friendly_git_ref
      - slack/approval:
          channel: workflow-approvals
          message: "A deployment for $CIRCLE_FRIENDLY_REF ($CIRCLE_SHA1) is pending approval. Click 'Visit Workflow' to approve."</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configure_ci_server">Configure CI Server</h3>
<div class="paragraph">
<p>Once we have our pipeline defined as code in our repository, we can hook it up to our CI server to start building.
Configure CircleCI to start building the <code>infrastructure-live</code> repo by adding the project to your org.</p>
</div>
<div class="paragraph">
<p>To add the <code>infrastructure-live</code> repo:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Login to CircleCI as <strong>the machine user</strong>. If you don&#8217;t have an account for the machine user, sign up using the GitHub
account of the machine user.</p>
</li>
<li>
<p>Go to the projects page for your org and click the <strong>Add Projects</strong> button.</p>
</li>
<li>
<p>Look for the <code>infrastructure-live</code> repo in the list, and click the <strong>Set Up Project</strong> button next to the repo.</p>
</li>
<li>
<p>Click the <strong>Start Building</strong> button to trigger the first build. Note that this build is expected to fail since we
haven&#8217;t configured the required environment variables.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Next, we need to configure the environment variables for the build:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Click the gear icon in the top right for the job to configure the job.</p>
</li>
<li>
<p>Add a <strong>User Key</strong> in the <strong>Checkout SSH keys</strong> settings for the build.</p>
</li>
<li>
<p>Click <strong>Environment Variables</strong> and add the following variables to the build:</p>
</li>
<li>
<p><code>AWS_ACCESS_KEY_ID</code> and <code>AWS_SECRET_ACCESS_KEY</code>: The AWS access key pair for the machine user to access your AWS
account. This should be a user in the security account with the ability to assume the auto deploy role in each of
the environments that you wish to configure CI/CD for.</p>
</li>
<li>
<p><code>GITHUB_OAUTH_TOKEN</code>: A personal access token for the machine user with access to Gruntwork Infrastructure as Code
Library.</p>
</li>
<li>
<p><code>SLACK_WEBHOOK</code>: A webhook for posting messages to your Slack org. You can refer to
<a href="https://api.slack.com/messaging/webhooks">the official Slack documentation</a> for instructions on how to configure a
webhook for your Slack org.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Once you have these configurations set, you should be able to start deploying your infrastructure in reaction to git
events!</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_next_steps">Next steps</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Now that you have a CI/CD pipeline for your infrastructure code, test it out by doing one of the following;</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Add a new component to <code>infrastructure-live</code> and see how it flows through the pipeline.</p>
</li>
<li>
<p>Make a change to one of the existing components that you have already deployed and see how it flows through the
pipeline.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2020-03-06 14:08:40 -0800
</div>
</div>
</body>
</html>